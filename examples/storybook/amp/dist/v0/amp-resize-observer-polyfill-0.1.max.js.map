{
  "version": 3,
  "sources": ["../../third_party/resize-observer-polyfill/ResizeObserver.install.js", "../../src/core/data-structures/promise.js", "../../src/core/types/array.js", "../../src/core/types/object/index.js", "../../src/internal-version.js", "../../src/core/types/string/url.js", "../../src/mode.js", "../../src/config.js", "../../src/log.js", "../../src/service.js", "../../src/polyfills/stubs/resize-observer-stub.js", "../../extensions/amp-resize-observer-polyfill/0.1/amp-resize-observer-polyfill.js"],
  "sourcesContent": ["export function installResizeObserver(global) {\n(function (global, factory) {\n    (global.ResizeObserver = factory());\n}(global, (function () { 'use strict';\n\n    /**\n     * A collection of shims that provide minimal functionality of the ES6 collections.\n     *\n     * These implementations are not meant to be used outside of the ResizeObserver\n     * modules as they cover only a limited range of use cases.\n     */\n    /* eslint-disable require-jsdoc, valid-jsdoc */\n    var MapShim = (function () {\n        if (typeof Map !== 'undefined') {\n            return Map;\n        }\n        /**\n         * Returns index in provided array that matches the specified key.\n         *\n         * @param {Array<Array>} arr\n         * @param {*} key\n         * @returns {number}\n         */\n        function getIndex(arr, key) {\n            var result = -1;\n            arr.some(function (entry, index) {\n                if (entry[0] === key) {\n                    result = index;\n                    return true;\n                }\n                return false;\n            });\n            return result;\n        }\n        return /** @class */ (function () {\n            function class_1() {\n                this.__entries__ = [];\n            }\n            Object.defineProperty(class_1.prototype, \"size\", {\n                /**\n                 * @returns {boolean}\n                 */\n                get: function () {\n                    return this.__entries__.length;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            /**\n             * @param {*} key\n             * @returns {*}\n             */\n            class_1.prototype.get = function (key) {\n                var index = getIndex(this.__entries__, key);\n                var entry = this.__entries__[index];\n                return entry && entry[1];\n            };\n            /**\n             * @param {*} key\n             * @param {*} value\n             * @returns {void}\n             */\n            class_1.prototype.set = function (key, value) {\n                var index = getIndex(this.__entries__, key);\n                if (~index) {\n                    this.__entries__[index][1] = value;\n                }\n                else {\n                    this.__entries__.push([key, value]);\n                }\n            };\n            /**\n             * @param {*} key\n             * @returns {void}\n             */\n            class_1.prototype.delete = function (key) {\n                var entries = this.__entries__;\n                var index = getIndex(entries, key);\n                if (~index) {\n                    entries.splice(index, 1);\n                }\n            };\n            /**\n             * @param {*} key\n             * @returns {void}\n             */\n            class_1.prototype.has = function (key) {\n                return !!~getIndex(this.__entries__, key);\n            };\n            /**\n             * @returns {void}\n             */\n            class_1.prototype.clear = function () {\n                this.__entries__.splice(0);\n            };\n            /**\n             * @param {Function} callback\n             * @param {*} [ctx=null]\n             * @returns {void}\n             */\n            class_1.prototype.forEach = function (callback, ctx) {\n                if (ctx === void 0) { ctx = null; }\n                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    callback.call(ctx, entry[1], entry[0]);\n                }\n            };\n            return class_1;\n        }());\n    })();\n\n    /**\n     * Defines non-writable/enumerable properties of the provided target object.\n     *\n     * @param {Object} target - Object for which to define properties.\n     * @param {Object} props - Properties to be defined.\n     * @returns {Object} Target object.\n     */\n    var defineConfigurable = (function (target, props) {\n        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n            var key = _a[_i];\n            Object.defineProperty(target, key, {\n                value: props[key],\n                enumerable: false,\n                writable: false,\n                configurable: true\n            });\n        }\n        return target;\n    });\n\n    // Returns global object of a current environment.\n    var global$1 = (function () {\n        if (typeof global !== 'undefined' && global.Math === Math) {\n            return global;\n        }\n        if (typeof self !== 'undefined' && self.Math === Math) {\n            return self;\n        }\n        if (typeof window !== 'undefined' && window.Math === Math) {\n            return window;\n        }\n        // eslint-disable-next-line no-new-func\n        return Function('return this')();\n    })();\n\n    /**\n     * Returns the global object associated with provided element.\n     *\n     * @param {Object} target\n     * @returns {Object}\n     */\n    var getWindowOf = (function (target) {\n        // Assume that the element is an instance of Node, which means that it\n        // has the \"ownerDocument\" property from which we can retrieve a\n        // corresponding global object.\n        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n        // Return the local global object if it's not possible extract one from\n        // provided element.\n        return ownerGlobal || global$1;\n    });\n\n    /**\n     * Detects whether window and document objects are available in current environment.\n     */\n    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n    // Placeholder of an empty content rectangle.\n    var emptyRect = createRectInit(0, 0, 0, 0);\n    /**\n     * Converts provided string to a number.\n     *\n     * @param {number|string} value\n     * @returns {number}\n     */\n    function toFloat(value) {\n        return parseFloat(value) || 0;\n    }\n    /**\n     * Extracts borders size from provided styles.\n     *\n     * @param {CSSStyleDeclaration} styles\n     * @param {...string} positions - Borders positions (top, right, ...)\n     * @returns {number}\n     */\n    function getBordersSize(styles) {\n        var positions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            positions[_i - 1] = arguments[_i];\n        }\n        return positions.reduce(function (size, position) {\n            var value = styles['border-' + position + '-width'];\n            return size + toFloat(value);\n        }, 0);\n    }\n    /**\n     * Extracts paddings sizes from provided styles.\n     *\n     * @param {CSSStyleDeclaration} styles\n     * @returns {Object} Paddings box.\n     */\n    function getPaddings(styles) {\n        var positions = ['top', 'right', 'bottom', 'left'];\n        var paddings = {};\n        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n            var position = positions_1[_i];\n            var value = styles['padding-' + position];\n            paddings[position] = toFloat(value);\n        }\n        return paddings;\n    }\n    /**\n     * Calculates content rectangle of provided SVG element.\n     *\n     * @param {SVGGraphicsElement} target - Element content rectangle of which needs\n     *      to be calculated.\n     * @returns {DOMRectInit}\n     */\n    function getSVGContentRect(target) {\n        var bbox = target.getBBox();\n        return createRectInit(0, 0, bbox.width, bbox.height);\n    }\n    /**\n     * Calculates content rectangle of provided HTMLElement.\n     *\n     * @param {HTMLElement} target - Element for which to calculate the content rectangle.\n     * @returns {DOMRectInit}\n     */\n    function getHTMLElementContentRect(target) {\n        // Client width & height properties can't be\n        // used exclusively as they provide rounded values.\n        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\n        // By this condition we can catch all non-replaced inline, hidden and\n        // detached elements. Though elements with width & height properties less\n        // than 0.5 will be discarded as well.\n        //\n        // Without it we would need to implement separate methods for each of\n        // those cases and it's not possible to perform a precise and performance\n        // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n        // gives wrong results for elements with width & height less than 0.5.\n        if (!clientWidth && !clientHeight) {\n            return emptyRect;\n        }\n        var styles = getWindowOf(target).getComputedStyle(target);\n        var paddings = getPaddings(styles);\n        var horizPad = paddings.left + paddings.right;\n        var vertPad = paddings.top + paddings.bottom;\n        // Computed styles of width & height are being used because they are the\n        // only dimensions available to JS that contain non-rounded values. It could\n        // be possible to utilize the getBoundingClientRect if only it's data wasn't\n        // affected by CSS transformations let alone paddings, borders and scroll bars.\n        var width = toFloat(styles.width), height = toFloat(styles.height);\n        // Width & height include paddings and borders when the 'border-box' box\n        // model is applied (except for IE).\n        if (styles.boxSizing === 'border-box') {\n            // Following conditions are required to handle Internet Explorer which\n            // doesn't include paddings and borders to computed CSS dimensions.\n            //\n            // We can say that if CSS dimensions + paddings are equal to the \"client\"\n            // properties then it's either IE, and thus we don't need to subtract\n            // anything, or an element merely doesn't have paddings/borders styles.\n            if (Math.round(width + horizPad) !== clientWidth) {\n                width -= getBordersSize(styles, 'left', 'right') + horizPad;\n            }\n            if (Math.round(height + vertPad) !== clientHeight) {\n                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n            }\n        }\n        // Following steps can't be applied to the document's root element as its\n        // client[Width/Height] properties represent viewport area of the window.\n        // Besides, it's as well not necessary as the <html> itself neither has\n        // rendered scroll bars nor it can be clipped.\n        if (!isDocumentElement(target)) {\n            // In some browsers (only in Firefox, actually) CSS width & height\n            // include scroll bars size which can be removed at this step as scroll\n            // bars are the only difference between rounded dimensions + paddings\n            // and \"client\" properties, though that is not always true in Chrome.\n            var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n            var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n            // Chrome has a rather weird rounding of \"client\" properties.\n            // E.g. for an element with content width of 314.2px it sometimes gives\n            // the client width of 315px and for the width of 314.7px it may give\n            // 314px. And it doesn't happen all the time. So just ignore this delta\n            // as a non-relevant.\n            if (Math.abs(vertScrollbar) !== 1) {\n                width -= vertScrollbar;\n            }\n            if (Math.abs(horizScrollbar) !== 1) {\n                height -= horizScrollbar;\n            }\n        }\n        return createRectInit(paddings.left, paddings.top, width, height);\n    }\n    /**\n     * Checks whether provided element is an instance of the SVGGraphicsElement.\n     *\n     * @param {Element} target - Element to be checked.\n     * @returns {boolean}\n     */\n    var isSVGGraphicsElement = (function () {\n        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n        // interface.\n        if (typeof SVGGraphicsElement !== 'undefined') {\n            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n        }\n        // If it's so, then check that element is at least an instance of the\n        // SVGElement and that it has the \"getBBox\" method.\n        // eslint-disable-next-line no-extra-parens\n        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\n            typeof target.getBBox === 'function'); };\n    })();\n    /**\n     * Checks whether provided element is a document element (<html>).\n     *\n     * @param {Element} target - Element to be checked.\n     * @returns {boolean}\n     */\n    function isDocumentElement(target) {\n        return target === getWindowOf(target).document.documentElement;\n    }\n    /**\n     * Calculates an appropriate content rectangle for provided html or svg element.\n     *\n     * @param {Element} target - Element content rectangle of which needs to be calculated.\n     * @returns {DOMRectInit}\n     */\n    function getContentRect(target) {\n        if (!isBrowser) {\n            return emptyRect;\n        }\n        if (isSVGGraphicsElement(target)) {\n            return getSVGContentRect(target);\n        }\n        return getHTMLElementContentRect(target);\n    }\n    /**\n     * Creates rectangle with an interface of the DOMRectReadOnly.\n     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\n     *\n     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\n     * @returns {DOMRectReadOnly}\n     */\n    function createReadOnlyRect(_a) {\n        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n        var rect = Object.create(Constr.prototype);\n        // Rectangle's properties are not writable and non-enumerable.\n        defineConfigurable(rect, {\n            x: x, y: y, width: width, height: height,\n            top: y,\n            right: x + width,\n            bottom: height + y,\n            left: x\n        });\n        return rect;\n    }\n    /**\n     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\n     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\n     *\n     * @param {number} x - X coordinate.\n     * @param {number} y - Y coordinate.\n     * @param {number} width - Rectangle's width.\n     * @param {number} height - Rectangle's height.\n     * @returns {DOMRectInit}\n     */\n    function createRectInit(x, y, width, height) {\n        return { x: x, y: y, width: width, height: height };\n    }\n\n    /**\n     * Class that is responsible for computations of the content rectangle of\n     * provided DOM element and for keeping track of it's changes.\n     */\n    var ResizeObservation = /** @class */ (function () {\n        /**\n         * Creates an instance of ResizeObservation.\n         *\n         * @param {Element} target - Element to be observed.\n         * @param {Node} rootNode - The root node of the element at the time\n         * of subscription.\n         */\n        function ResizeObservation(target, rootNode) {\n            /**\n             * Broadcasted width of content rectangle.\n             *\n             * @type {number}\n             */\n            this.broadcastWidth = 0;\n            /**\n             * Broadcasted height of content rectangle.\n             *\n             * @type {number}\n             */\n            this.broadcastHeight = 0;\n            /**\n             * Reference to the last observed content rectangle.\n             *\n             * @private {DOMRectInit}\n             */\n            this.contentRect_ = createRectInit(0, 0, 0, 0);\n            this.target = target;\n            this.rootNode = rootNode;\n        }\n        /**\n         * Updates content rectangle and tells whether it's width or height properties\n         * have changed since the last broadcast.\n         *\n         * @returns {boolean}\n         */\n        ResizeObservation.prototype.isActive = function () {\n            var rect = getContentRect(this.target);\n            this.contentRect_ = rect;\n            return (rect.width !== this.broadcastWidth ||\n                rect.height !== this.broadcastHeight);\n        };\n        /**\n         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\n         * from the corresponding properties of the last observed content rectangle.\n         *\n         * @returns {DOMRectInit} Last observed content rectangle.\n         */\n        ResizeObservation.prototype.broadcastRect = function () {\n            var rect = this.contentRect_;\n            this.broadcastWidth = rect.width;\n            this.broadcastHeight = rect.height;\n            return rect;\n        };\n        return ResizeObservation;\n    }());\n\n    var ResizeObserverEntry = /** @class */ (function () {\n        /**\n         * Creates an instance of ResizeObserverEntry.\n         *\n         * @param {Element} target - Element that is being observed.\n         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\n         */\n        function ResizeObserverEntry(target, rectInit) {\n            var contentRect = createReadOnlyRect(rectInit);\n            // According to the specification following properties are not writable\n            // and are also not enumerable in the native implementation.\n            //\n            // Property accessors are not being used as they'd require to define a\n            // private WeakMap storage which may cause memory leaks in browsers that\n            // don't support this type of collections.\n            defineConfigurable(this, { target: target, contentRect: contentRect });\n        }\n        return ResizeObserverEntry;\n    }());\n\n    /**\n     * A shim for the `Node.getRootNode()` API.\n     *\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode for\n     * more info.\n     *\n     * @param {Node} node\n     * @returns {Node}\n     */\n    function getRootNode(node) {\n        if (typeof node.getRootNode === 'function') {\n            return node.getRootNode();\n        }\n        var n;\n        // eslint-disable-next-line no-empty\n        for (n = node; n.parentNode; n = n.parentNode) { }\n        return n;\n    }\n\n    // Check if IntersectionObserver is available.\n    var intersectionObserverSupported = typeof IntersectionObserver !== 'undefined';\n    var ResizeObserverSPI = /** @class */ (function () {\n        /**\n         * Creates a new instance of ResizeObserver.\n         *\n         * @param {ResizeObserverCallback} callback - Callback function that is invoked\n         *      when one of the observed elements changes it's content dimensions.\n         * @param {GlobalResizeObserverController} controller - Controller instance which\n         *      is responsible for the updates of observer.\n         * @param {ResizeObserver} callbackCtx - Reference to the public\n         *      ResizeObserver instance which will be passed to callback function.\n         */\n        function ResizeObserverSPI(callback, controller, callbackCtx) {\n            var _this = this;\n            /**\n             * Collection of resize observations that have detected changes in dimensions\n             * of elements.\n             *\n             * @private {Array<ResizeObservation>}\n             */\n            this.activeObservations_ = [];\n            /**\n             * Registry of the ResizeObservation instances.\n             *\n             * @private {Map<Element, ResizeObservation>}\n             */\n            this.observations_ = new MapShim();\n            /**\n             * The mapping between a root node and a set of targets tracked within\n             * this root node.\n             *\n             * @private {Map<Node, Array<Element>>}\n             */\n            this.rootNodes_ = new MapShim();\n            /**\n             * An instance of the intersection observer when available. There are a\n             * lot more browser versions that support the `IntersectionObserver`, but\n             * not the `ResizeObserver`. When `IntersectionObserver` is available it\n             * can be used to pick up DOM additions and removals more timely without\n             * significant costs.\n             *\n             * @private {IntersectionObserver}\n             */\n            this.intersectionObserver_ = null;\n            if (typeof callback !== 'function') {\n                throw new TypeError('The callback provided as parameter 1 is not a function.');\n            }\n            this.callback_ = callback;\n            this.controller_ = controller;\n            this.callbackCtx_ = callbackCtx;\n            if (intersectionObserverSupported) {\n                this.intersectionObserver_ = new IntersectionObserver(function () { return _this.checkRootChanges_(); });\n            }\n        }\n        /**\n         * Starts observing provided element.\n         *\n         * @param {Element} target - Element to be observed.\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.observe = function (target) {\n            if (!arguments.length) {\n                throw new TypeError('1 argument required, but only 0 present.');\n            }\n            // Do nothing if current environment doesn't have the Element interface.\n            if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n                return;\n            }\n            if (!(target instanceof getWindowOf(target).Element)) {\n                throw new TypeError('parameter 1 is not of type \"Element\".');\n            }\n            var observations = this.observations_;\n            // Do nothing if element is already being observed.\n            if (observations.has(target)) {\n                return;\n            }\n            var rootNode = getControlledRootNode(target, target.ownerDocument);\n            observations.set(target, new ResizeObservation(target, rootNode));\n            var rootNodeTargets = this.rootNodes_.get(rootNode);\n            if (!rootNodeTargets) {\n                rootNodeTargets = [];\n                this.rootNodes_.set(rootNode, rootNodeTargets);\n                this.controller_.addObserver(rootNode, this);\n            }\n            rootNodeTargets.push(target);\n            if (this.intersectionObserver_) {\n                this.intersectionObserver_.observe(target);\n            }\n            // Force the update of observations.\n            this.controller_.refresh(rootNode);\n        };\n        /**\n         * Stops observing provided element.\n         *\n         * @param {Element} target - Element to stop observing.\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.unobserve = function (target) {\n            if (!arguments.length) {\n                throw new TypeError('1 argument required, but only 0 present.');\n            }\n            // Do nothing if current environment doesn't have the Element interface.\n            if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n                return;\n            }\n            if (!(target instanceof getWindowOf(target).Element)) {\n                throw new TypeError('parameter 1 is not of type \"Element\".');\n            }\n            var observations = this.observations_;\n            var observation = observations.get(target);\n            // Do nothing if element is not being observed.\n            if (!observation) {\n                return;\n            }\n            observations.delete(target);\n            if (this.intersectionObserver_) {\n                this.intersectionObserver_.unobserve(target);\n            }\n            // Disconnect the root if no longer used.\n            var rootNode = observation.rootNode;\n            var rootNodeTargets = this.rootNodes_.get(rootNode);\n            if (rootNodeTargets) {\n                var index = rootNodeTargets.indexOf(target);\n                if (~index) {\n                    rootNodeTargets.splice(index, 1);\n                }\n                if (rootNodeTargets.length === 0) {\n                    this.rootNodes_.delete(rootNode);\n                    this.controller_.removeObserver(rootNode, this);\n                }\n            }\n        };\n        /**\n         * Stops observing all elements.\n         *\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.disconnect = function () {\n            var _this = this;\n            this.clearActive();\n            this.observations_.clear();\n            this.rootNodes_.forEach(function (_, rootNode) {\n                _this.controller_.removeObserver(rootNode, _this);\n            });\n            this.rootNodes_.clear();\n            if (this.intersectionObserver_) {\n                this.intersectionObserver_.disconnect();\n                this.intersectionObserver_ = null;\n            }\n        };\n        /**\n         * Collects observation instances the associated element of which has changed\n         * it's content rectangle.\n         *\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.gatherActive = function () {\n            var _this = this;\n            this.checkRootChanges_();\n            this.clearActive();\n            this.observations_.forEach(function (observation) {\n                if (observation.isActive()) {\n                    _this.activeObservations_.push(observation);\n                }\n            });\n        };\n        /**\n         * Invokes initial callback function with a list of ResizeObserverEntry\n         * instances collected from active resize observations.\n         *\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.broadcastActive = function () {\n            // Do nothing if observer doesn't have active observations.\n            if (!this.hasActive()) {\n                return;\n            }\n            var ctx = this.callbackCtx_;\n            // Create ResizeObserverEntry instance for every active observation.\n            var entries = this.activeObservations_.map(function (observation) {\n                return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n            });\n            this.callback_.call(ctx, entries, ctx);\n            this.clearActive();\n        };\n        /**\n         * Clears the collection of active observations.\n         *\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.clearActive = function () {\n            this.activeObservations_.splice(0);\n        };\n        /**\n         * Tells whether observer has active observations.\n         *\n         * @returns {boolean}\n         */\n        ResizeObserverSPI.prototype.hasActive = function () {\n            return this.activeObservations_.length > 0;\n        };\n        /**\n         * Check if any of the targets have changed the root node. For instance,\n         * an element could be moved from the main DOM to a shadow root.\n         *\n         * @private\n         * @returns {void}\n         */\n        ResizeObserverSPI.prototype.checkRootChanges_ = function () {\n            var _this = this;\n            var changedRootTargets = null;\n            this.observations_.forEach(function (observation) {\n                var target = observation.target, oldRootNode = observation.rootNode;\n                var rootNode = getControlledRootNode(target, oldRootNode);\n                if (rootNode !== oldRootNode) {\n                    if (!changedRootTargets) {\n                        changedRootTargets = [];\n                    }\n                    changedRootTargets.push(target);\n                }\n            });\n            if (changedRootTargets) {\n                changedRootTargets.forEach(function (target) {\n                    _this.unobserve(target);\n                    _this.observe(target);\n                });\n            }\n        };\n        return ResizeObserverSPI;\n    }());\n    /**\n     * Find the most appropriate root node that should be monitored for events\n     * related to this target.\n     *\n     * @param {Node} target\n     * @param {Node} def\n     * @returns {Node}\n     */\n    function getControlledRootNode(target, def) {\n        var rootNode = getRootNode(target);\n        // DOCUMENT_NODE = 9\n        // DOCUMENT_FRAGMENT_NODE = 11 (shadow root)\n        if (rootNode.nodeType === 9 ||\n            rootNode.nodeType === 11) {\n            return rootNode;\n        }\n        return def;\n    }\n\n    /**\n     * A shim for the requestAnimationFrame which falls back to the setTimeout if\n     * first one is not supported.\n     *\n     * @returns {number} Requests' identifier.\n     */\n    var requestAnimationFrame$1 = (function () {\n        if (typeof requestAnimationFrame === 'function') {\n            // It's required to use a bounded function because IE sometimes throws\n            // an \"Invalid calling object\" error if rAF is invoked without the global\n            // object on the left hand side.\n            return requestAnimationFrame.bind(global$1);\n        }\n        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n    })();\n\n    // Defines minimum timeout before adding a trailing call.\n    var trailingTimeout = 2;\n    /**\n     * Creates a wrapper function which ensures that provided callback will be\n     * invoked only once during the specified delay period.\n     *\n     * @param {Function} callback - Function to be invoked after the delay period.\n     * @param {number} delay - Delay after which to invoke callback.\n     * @returns {Function}\n     */\n    function throttle (callback, delay) {\n        var leadingCall = false, trailingCall = false, lastCallTime = 0;\n        /**\n         * Invokes the original callback function and schedules new invocation if\n         * the \"proxy\" was called during current request.\n         *\n         * @returns {void}\n         */\n        function resolvePending() {\n            if (leadingCall) {\n                leadingCall = false;\n                callback();\n            }\n            if (trailingCall) {\n                proxy();\n            }\n        }\n        /**\n         * Callback invoked after the specified delay. It will further postpone\n         * invocation of the original function delegating it to the\n         * requestAnimationFrame.\n         *\n         * @returns {void}\n         */\n        function timeoutCallback() {\n            requestAnimationFrame$1(resolvePending);\n        }\n        /**\n         * Schedules invocation of the original function.\n         *\n         * @returns {void}\n         */\n        function proxy() {\n            var timeStamp = Date.now();\n            if (leadingCall) {\n                // Reject immediately following calls.\n                if (timeStamp - lastCallTime < trailingTimeout) {\n                    return;\n                }\n                // Schedule new call to be in invoked when the pending one is resolved.\n                // This is important for \"transitions\" which never actually start\n                // immediately so there is a chance that we might miss one if change\n                // happens amids the pending invocation.\n                trailingCall = true;\n            }\n            else {\n                leadingCall = true;\n                trailingCall = false;\n                setTimeout(timeoutCallback, delay);\n            }\n            lastCallTime = timeStamp;\n        }\n        return proxy;\n    }\n\n    // Minimum delay before invoking the update of observers.\n    var REFRESH_DELAY = 20;\n    // A list of substrings of CSS properties used to find transition events that\n    // might affect dimensions of observed elements.\n    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n    // Check if MutationObserver is available.\n    var mutationObserverSupported = typeof MutationObserver !== 'undefined';\n    /**\n     * The controller that tracks the resize-related events for the specified\n     * root node. The `GlobalResizeObserverController` uses a per-root-node\n     * instance of this class to track mutations and other events within the\n     * specified root.\n     */\n    var ResizeObserverController = /** @class */ (function () {\n        /**\n         * Creates a new instance of ResizeObserverController.\n         *\n         * @private\n         * @param {Node} rootNode - The root node that this controller monitors.\n         * @param {GlobalResizeObserverController} globalController - The global\n         * controller for all roots.\n         */\n        function ResizeObserverController(rootNode, globalController) {\n            /**\n             * The root node that this controller monitors.\n             *\n             * @private {Node}\n             */\n            this.rootNode_ = null;\n            /**\n             * The global controller.\n             *\n             * @private {GlobalResizeObserverController}\n             */\n            this.globalController_ = null;\n            /**\n             * Indicates whether DOM listeners have been added.\n             *\n             * @private {boolean}\n             */\n            this.connected_ = false;\n            /**\n             * Tells that controller has subscribed for Mutation Events.\n             *\n             * @private {boolean}\n             */\n            this.mutationEventsAdded_ = false;\n            /**\n             * Keeps reference to the instance of MutationObserver.\n             *\n             * @private {MutationObserver}\n             */\n            this.mutationsObserver_ = null;\n            /**\n             * Monitors the shadow root host for size changes.\n             *\n             * @private {ResizeObserverSPI}\n             */\n            this.hostObserver_ = null;\n            /**\n             * A list of connected observers.\n             *\n             * @private {Array<ResizeObserverSPI>}\n             */\n            this.observers_ = [];\n            this.rootNode_ = rootNode;\n            this.globalController_ = globalController;\n            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n        }\n        /**\n         * Adds observer to observers list.\n         *\n         * @param {ResizeObserverSPI} observer - Observer to be added.\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.addObserver = function (observer) {\n            if (!~this.observers_.indexOf(observer)) {\n                this.observers_.push(observer);\n            }\n            // Add listeners if they haven't been added yet.\n            if (!this.connected_) {\n                this.connect_();\n            }\n        };\n        /**\n         * Removes observer from observers list.\n         *\n         * @param {ResizeObserverSPI} observer - Observer to be removed.\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.removeObserver = function (observer) {\n            var observers = this.observers_;\n            var index = observers.indexOf(observer);\n            // Remove observer if it's present in registry.\n            if (~index) {\n                observers.splice(index, 1);\n            }\n            // Remove listeners if controller has no connected observers.\n            if (!observers.length && this.connected_) {\n                this.disconnect_();\n            }\n        };\n        /**\n         * Invokes the update of observers. It will continue running updates insofar\n         * it detects changes.\n         *\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.refresh = function () {\n            var changesDetected = this.updateObservers_();\n            // Continue running updates if changes have been detected as there might\n            // be future ones caused by CSS transitions.\n            if (changesDetected) {\n                this.refresh();\n            }\n        };\n        /**\n         * Updates every observer from observers list and notifies them of queued\n         * entries.\n         *\n         * @private\n         * @returns {boolean} Returns \"true\" if any observer has detected changes in\n         *      dimensions of it's elements.\n         */\n        ResizeObserverController.prototype.updateObservers_ = function () {\n            // Collect observers that have active observations.\n            var activeObservers = this.observers_.filter(function (observer) {\n                return observer.gatherActive(), observer.hasActive();\n            });\n            // Deliver notifications in a separate cycle in order to avoid any\n            // collisions between observers, e.g. when multiple instances of\n            // ResizeObserver are tracking the same element and the callback of one\n            // of them changes content dimensions of the observed target. Sometimes\n            // this may result in notifications being blocked for the rest of observers.\n            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n            return activeObservers.length > 0;\n        };\n        /**\n         * Initializes DOM listeners.\n         *\n         * @private\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.connect_ = function () {\n            // Do nothing if running in a non-browser environment or if listeners\n            // have been already added.\n            if (!isBrowser || this.connected_) {\n                return;\n            }\n            var rootNode = this.rootNode_;\n            var doc = rootNode.ownerDocument || rootNode;\n            var win = doc.defaultView;\n            // Subscription to the \"Transitionend\" event is used as a workaround for\n            // delayed transitions. This way it's possible to capture at least the\n            // final state of an element.\n            rootNode.addEventListener('transitionend', this.onTransitionEnd_, true);\n            if (win) {\n                win.addEventListener('resize', this.refresh, true);\n            }\n            if (mutationObserverSupported) {\n                this.mutationsObserver_ = new MutationObserver(this.refresh);\n                try {\n                    this.mutationsObserver_.observe(rootNode, {\n                        attributes: true,\n                        childList: true,\n                        characterData: true,\n                        subtree: true\n                    });\n                }\n                catch (e) {\n                    // A Shadow DOM polyfill might fail when oberving a \"synthetic\"\n                    // ShadowRoot object. Ignore the error. The additional data\n                    // will arrive from the host observer below.\n                }\n                if (rootNode.host) {\n                    this.mutationsObserver_.observe(rootNode.host, {\n                        attributes: true,\n                        childList: true,\n                        characterData: true,\n                        subtree: true\n                    });\n                }\n            }\n            else {\n                rootNode.addEventListener('DOMSubtreeModified', this.refresh, true);\n                this.mutationEventsAdded_ = true;\n            }\n            // It's a shadow root. Monitor the host.\n            if (rootNode.host) {\n                this.hostObserver_ = new ResizeObserverSPI(this.refresh, this.globalController_, this);\n                this.hostObserver_.observe(rootNode.host);\n            }\n            this.connected_ = true;\n        };\n        /**\n         * Removes DOM listeners.\n         *\n         * @private\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.disconnect_ = function () {\n            // Do nothing if running in a non-browser environment or if listeners\n            // have been already removed.\n            if (!isBrowser || !this.connected_) {\n                return;\n            }\n            var rootNode = this.rootNode_;\n            var doc = rootNode.ownerDocument || rootNode;\n            var win = doc.defaultView;\n            rootNode.removeEventListener('transitionend', this.onTransitionEnd_, true);\n            if (win) {\n                win.removeEventListener('resize', this.refresh, true);\n            }\n            if (this.mutationsObserver_) {\n                this.mutationsObserver_.disconnect();\n            }\n            if (this.mutationEventsAdded_) {\n                rootNode.removeEventListener('DOMSubtreeModified', this.refresh, true);\n            }\n            if (this.hostObserver_) {\n                this.hostObserver_.disconnect();\n            }\n            this.hostObserver_ = null;\n            this.mutationsObserver_ = null;\n            this.mutationEventsAdded_ = false;\n            this.connected_ = false;\n        };\n        /**\n         * \"Transitionend\" event handler.\n         *\n         * @private\n         * @param {TransitionEvent} event\n         * @returns {void}\n         */\n        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\n            // Detect whether transition may affect dimensions of an element.\n            var isReflowProperty = transitionKeys.some(function (key) {\n                return !!~propertyName.indexOf(key);\n            });\n            if (isReflowProperty) {\n                this.refresh();\n            }\n        };\n        return ResizeObserverController;\n    }());\n\n    /**\n     * Singleton controller class which handles updates of ResizeObserver instances.\n     */\n    var GlobalResizeObserverController = /** @class */ (function () {\n        function GlobalResizeObserverController() {\n            /**\n             * A mapping from a DOM root node and a respective controller. A root node\n             * could be the main document, a same-origin iframe, or a shadow root.\n             * See https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n             * for more info.\n             *\n             * @private {Map<Node, ResizeObserverController>}\n             */\n            this.rootNodeControllers_ = typeof WeakMap !== 'undefined' ? new WeakMap() : new Map();\n        }\n        /**\n         * Adds observer to observers list.\n         *\n         * @param {Node} rootNode - The root node for which the observer is added.\n         * @param {ResizeObserverSPI} observer - Observer to be added.\n         * @returns {void}\n         */\n        GlobalResizeObserverController.prototype.addObserver = function (rootNode, observer) {\n            var rootNodeController = this.rootNodeControllers_.get(rootNode);\n            if (!rootNodeController) {\n                rootNodeController = new ResizeObserverController(rootNode, this);\n                this.rootNodeControllers_.set(rootNode, rootNodeController);\n            }\n            rootNodeController.addObserver(observer);\n        };\n        /**\n         * Removes observer from observers list.\n         *\n         * @param {Node} rootNode - The root node from which the observer is removed.\n         * @param {ResizeObserverSPI} observer - Observer to be removed.\n         * @returns {void}\n         */\n        GlobalResizeObserverController.prototype.removeObserver = function (rootNode, observer) {\n            var rootNodeController = this.rootNodeControllers_.get(rootNode);\n            if (rootNodeController) {\n                rootNodeController.removeObserver(observer);\n            }\n        };\n        /**\n         * Invokes the update of observers. It will continue running updates insofar\n         * it detects changes.\n         *\n         * @param {Node} rootNode - The root node to refresh.\n         * @returns {void}\n         */\n        GlobalResizeObserverController.prototype.refresh = function (rootNode) {\n            var rootNodeController = this.rootNodeControllers_.get(rootNode);\n            if (rootNodeController) {\n                rootNodeController.refresh();\n            }\n        };\n        /**\n         * Returns instance of the GlobalResizeObserverController.\n         *\n         * @returns {GlobalResizeObserverController}\n         */\n        GlobalResizeObserverController.getInstance = function () {\n            if (!this.instance_) {\n                this.instance_ = new GlobalResizeObserverController();\n            }\n            return this.instance_;\n        };\n        /**\n         * Holds reference to the controller's instance.\n         *\n         * @private {GlobalResizeObserverController}\n         */\n        GlobalResizeObserverController.instance_ = null;\n        return GlobalResizeObserverController;\n    }());\n\n    // Registry of internal observers. If WeakMap is not available use current shim\n    // for the Map collection as it has all required methods and because WeakMap\n    // can't be fully polyfilled anyway.\n    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n    /**\n     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\n     * exposing only those methods and properties that are defined in the spec.\n     */\n    var ResizeObserver = /** @class */ (function () {\n        /**\n         * Creates a new instance of ResizeObserver.\n         *\n         * @param {ResizeObserverCallback} callback - Callback that is invoked when\n         *      dimensions of the observed elements change.\n         */\n        function ResizeObserver(callback) {\n            if (!(this instanceof ResizeObserver)) {\n                throw new TypeError('Cannot call a class as a function.');\n            }\n            if (!arguments.length) {\n                throw new TypeError('1 argument required, but only 0 present.');\n            }\n            var controller = GlobalResizeObserverController.getInstance();\n            var observer = new ResizeObserverSPI(callback, controller, this);\n            observers.set(this, observer);\n        }\n        return ResizeObserver;\n    }());\n    // Expose public methods of ResizeObserver.\n    [\n        'observe',\n        'unobserve',\n        'disconnect'\n    ].forEach(function (method) {\n        ResizeObserver.prototype[method] = function () {\n            var _a;\n            return (_a = observers.get(this))[method].apply(_a, arguments);\n        };\n    });\n\n    var index = (function () {\n        // Export existing implementation if available.\n        if (typeof global$1.ResizeObserver !== 'undefined') {\n            return global$1.ResizeObserver;\n        }\n        return ResizeObserver;\n    })();\n\n    return index;\n\n})));\n}\n", "/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet resolved;\n\n/**\n * Returns a cached resolved promise.\n * Babel converts direct calls to Promise.resolve() (with no arguments) into\n * calls to this.\n *\n * @return {!Promise<undefined>}\n */\nexport function resolvedPromise() {\n  if (resolved) {\n    return resolved;\n  }\n\n  // It's important that we call with `undefined` here, to prevent a transform\n  // recursion. If we didn't pass an arg, then the transformer would replace\n  // this callsite with a call to `resolvedPromise()`.\n  resolved = Promise.resolve(undefined);\n  return resolved;\n}\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /** Constructor. */\n  constructor() {\n    /** @const {!Promise<T>} */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      /** @const {function(T=)} */\n      this.resolve = res;\n      /** @const {function(*=)} */\n      this.reject = rej;\n    });\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise((resolve) => {\n    resolve(fn());\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!IThenable>=} opt_promises\n   */\n  constructor(opt_promises) {\n    /** @private @const {!Deferred} */\n    this.deferred_ = new Deferred();\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (const promise of opt_promises) {\n        this.add(promise);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!IThenable} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    promise.then(\n      (result) => {\n        if (this.count_ === countAtAdd) {\n          this.deferred_.resolve(result);\n        }\n      },\n      (error) => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.deferred_.reject(error);\n        }\n      }\n    );\n    return this.deferred_.promise;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.deferred_.promise.then(opt_resolve, opt_reject);\n  }\n}\n", "/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\nexport function toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\nexport const {isArray} = Array;\n\n/**\n * If the specified argument is an array, it's returned as is. If it's a\n * single item, the array containing this item is created and returned.\n *\n * The double-template pattern here solves a bug where CC can be passed a value\n * with declared type {string|!Array<string>} and return a value with a type of\n * {!Array<string|Array<string>>}.\n *\n * @param {!Array<T>|S} arrayOrSingleItem\n * @return {!Array<T>|!Array<S>}\n * @template S\n * @template T\n */\nexport function arrayOrSingleItemToArray(arrayOrSingleItem) {\n  return isArray(arrayOrSingleItem)\n    ? /** @type {!Array<T>} */ (arrayOrSingleItem)\n    : [/** @type {!S} */ (arrayOrSingleItem)];\n}\n\n/**\n * Compares if two arrays contains exactly same elements of same number\n * of same order. Note that it does NOT handle NaN case as expected.\n *\n * @param {!Array<T>} arr1\n * @param {!Array<T>} arr2\n * @return {boolean}\n * @template T\n */\nexport function areEqualOrdered(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Removes elements that shouldRemove returns true for from the array.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} shouldRemove\n * @return {!Array<T>}\n * @template T\n */\nexport function remove(array, shouldRemove) {\n  const removed = [];\n  let index = 0;\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    if (shouldRemove(item, i, array)) {\n      removed.push(item);\n    } else {\n      if (index < i) {\n        array[index] = item;\n      }\n      index++;\n    }\n  }\n  if (index < array.length) {\n    array.length = index;\n  }\n  return removed;\n}\n\n/**\n * Returns the index of the first element matching the predicate.\n * Like Array#findIndex.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} predicate\n * @return {number}\n * @template T\n */\nexport function findIndex(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Converts the given iterator to an array.\n *\n * @param {!Iterator<T>} iterator\n * @return {Array<T>}\n * @template T\n */\nexport function fromIterator(iterator) {\n  const array = [];\n  for (let e = iterator.next(); !e.done; e = iterator.next()) {\n    array.push(e.value);\n  }\n  return array;\n}\n\n/**\n * Adds item to array if it is not already present.\n *\n * @param {Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function pushIfNotExist(array, item) {\n  if (array.indexOf(item) < 0) {\n    array.push(item);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the first matching item in the array. Returns `true` if the array\n * has changed.\n *\n * @param {!Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function removeItem(array, item) {\n  const index = array.indexOf(item);\n  if (index == -1) {\n    return false;\n  }\n  array.splice(index, 1);\n  return true;\n}\n\n/**\n * Returns the last item in an array.\n *\n * @param {Array<T>} array\n * @template T\n * @return {?T}\n */\nexport function lastItem(array) {\n  return array[array.length - 1];\n}\n", "/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* @const */\nconst {hasOwnProperty: hasOwn_, toString: toString_} = Object.prototype;\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString_.call(value) === '[object Object]';\n}\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {d, s, t} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    for (const key of Object.keys(s)) {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          continue;\n        }\n      }\n      t[key] = newValue;\n    }\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * @param {!Object|null|undefined} o1\n * @param {!Object|null|undefined} o2\n * @return {boolean}\n */\nexport function objectsEqualShallow(o1, o2) {\n  if (o1 == null || o2 == null) {\n    // Null is only equal to null, and undefined to undefined.\n    return o1 === o2;\n  }\n\n  for (const k in o1) {\n    if (o1[k] !== o2[k]) {\n      return false;\n    }\n  }\n  for (const k in o2) {\n    if (o2[k] !== o1[k]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {T} obj\n * @param {string} prop\n * @param {function(T, string):R} factory\n * @return {R}\n * @template T,R\n */\nexport function memo(obj, prop, factory) {\n  let result = /** @type {?R} */ (obj[prop]);\n  if (result === undefined) {\n    result = factory(obj, prop);\n    obj[prop] = result;\n  }\n  return result;\n}\n\n/**\n * Recreates objects with prototype-less copies.\n * @param {!JsonObject} obj\n * @return {!JsonObject}\n */\nexport function recreateNonProtoObject(obj) {\n  const copy = map();\n  for (const k in obj) {\n    if (!hasOwn(obj, k)) {\n      continue;\n    }\n    const v = obj[k];\n    copy[k] = isObject(v) ? recreateNonProtoObject(v) : v;\n  }\n  return /** @type {!JsonObject} */ (copy);\n}\n\n/**\n * Returns a value from an object for a field-based expression. The expression\n * is a simple nested dot-notation of fields, such as `field1.field2`. If any\n * field in a chain does not exist or is not an object or array, the returned\n * value will be `undefined`.\n *\n * @param {!JsonObject} obj\n * @param {string} expr\n * @return {*}\n */\nexport function getValueForExpr(obj, expr) {\n  // The `.` indicates \"the object itself\".\n  if (expr == '.') {\n    return obj;\n  }\n  // Otherwise, navigate via properties.\n  const parts = expr.split('.');\n  let value = obj;\n  for (const part of parts) {\n    if (\n      part &&\n      value &&\n      value[part] !== undefined &&\n      typeof value == 'object' &&\n      hasOwn(value, part)\n    ) {\n      value = value[part];\n      continue;\n    }\n    value = undefined;\n    break;\n  }\n  return value;\n}\n", "/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns the internal AMP runtime version. Note that this is not the RTV,\n * which is a prefix and the runtime version.\n *\n * The call sites for this function are replaced with a compile time constant\n * string.\n *\n * @return {string}\n */\nexport function internalRuntimeVersion() {\n  return '$internalRuntimeVersion$';\n}\n", "/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {map} from '../object';\n\nconst QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * @param {string} component\n * @param {string=} fallback\n * @return {string}\n */\nexport function tryDecodeUriComponent(component, fallback = '') {\n  try {\n    return decodeURIComponent(component);\n  } catch (e) {\n    return fallback;\n  }\n}\n\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\nexport function parseQueryString(queryString) {\n  const params = map();\n  if (!queryString) {\n    return params;\n  }\n\n  let match;\n  while ((match = QUERY_STRING_REGEX.exec(queryString))) {\n    const name = tryDecodeUriComponent(match[1], match[1]);\n    const value = match[2]\n      ? tryDecodeUriComponent(match[2].replace(/\\+/g, ' '), match[2])\n      : '';\n    params[name] = value;\n  }\n  return params;\n}\n", "/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {internalRuntimeVersion} from './internal-version';\nimport {parseQueryString} from './core/types/string/url';\n\n/**\n * @typedef {{\n *   localDev: boolean,\n *   development: boolean,\n *   minified: boolean,\n *   test: boolean,\n *   examiner: boolean,\n *   log: (string|undefined),\n *   version: string,\n *   rtvVersion: string,\n *   runtime: (null|string|undefined),\n *   a4aId: (null|string|undefined),\n *   esm: (boolean|undefined),\n * }}\n */\nexport let ModeDef;\n\n/**\n * `rtvVersion` is the prefixed version we serve off of the cdn.\n * The prefix denotes canary(00) or prod(01) or an experiment version ( > 01).\n * @type {string}\n */\nlet rtvVersion = '';\n\n/**\n * Provides info about the current app.\n * @param {?Window=} opt_win\n * @return {!ModeDef}\n */\nexport function getMode(opt_win) {\n  const win = opt_win || self;\n  if (win.__AMP_MODE) {\n    return win.__AMP_MODE;\n  }\n  return (win.__AMP_MODE = getMode_(win));\n}\n\n/**\n * Provides info about the current app.\n * @param {!Window} win\n * @return {!ModeDef}\n */\nfunction getMode_(win) {\n  // TODO(erwinmombay): simplify the logic here\n  const AMP_CONFIG = self.AMP_CONFIG || {};\n\n  // Magic constants that are replaced by closure compiler.\n  // IS_MINIFIED is always replaced with true when closure compiler is used\n  // while IS_FORTESTING is only replaced when `amp dist` is called without the\n  // --fortesting flag.\n  const IS_FORTESTING = true;\n  const IS_MINIFIED = false;\n\n  const runningTests =\n    IS_FORTESTING && !!(AMP_CONFIG.test || win.__AMP_TEST || win['__karma__']);\n  const isLocalDev = IS_FORTESTING && (!!AMP_CONFIG.localDev || runningTests);\n  const hashQuery = parseQueryString(\n    // location.originalHash is set by the viewer when it removes the fragment\n    // from the URL.\n    win.location['originalHash'] || win.location.hash\n  );\n\n  if (!rtvVersion) {\n    rtvVersion = getRtvVersion(win);\n  }\n\n  // The `minified`, `test` and `localDev` properties are replaced\n  // as boolean literals when we run `amp dist` without the `--fortesting`\n  // flags. This improved DCE on the production file we deploy as the code\n  // paths for localhost/testing/development are eliminated.\n  return {\n    localDev: isLocalDev,\n    development: isModeDevelopment(win),\n    examiner: hashQuery['development'] == '2',\n    esm: IS_ESM,\n    // amp-geo override\n    geoOverride: hashQuery['amp-geo'],\n    minified: IS_MINIFIED,\n    test: runningTests,\n    log: hashQuery['log'],\n    version: internalRuntimeVersion(),\n    rtvVersion,\n  };\n}\n\n/**\n * Retrieve the `rtvVersion` which will have a numeric prefix\n * denoting canary/prod/experiment (unless `isLocalDev` is true).\n *\n * @param {!Window} win\n * @return {string}\n */\nfunction getRtvVersion(win) {\n  if (win.AMP_CONFIG && win.AMP_CONFIG.v) {\n    return win.AMP_CONFIG.v;\n  }\n\n  // Currently `internalRuntimeVersion` and thus `mode.version` contain only\n  // major version. The full version however must also carry the minor version.\n  // We will default to production default `01` minor version for now.\n  // TODO(erwinmombay): decide whether internalRuntimeVersion should contain\n  // minor version.\n  return `01${internalRuntimeVersion()}`;\n}\n\n/**\n * Triggers validation or enable pub level logging. Validation can be\n * bypassed via #validate=0.\n * Note that AMP_DEV_MODE flag is used for testing purposes.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isModeDevelopment(win) {\n  const hashQuery = parseQueryString(\n    win.location['originalHash'] || win.location.hash\n  );\n  return !!(\n    ['1', 'actions', 'amp', 'amp4ads', 'amp4email'].includes(\n      hashQuery['development']\n    ) || win.AMP_DEV_MODE\n  );\n}\n\n/**\n * @param {!Window} win\n * @return {string}\n * @visibleForTesting\n */\nexport function getRtvVersionForTesting(win) {\n  return getRtvVersion(win);\n}\n\n/** @visibleForTesting */\nexport function resetRtvVersionForTesting() {\n  rtvVersion = '';\n}\n", "/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nconst env = self.AMP_CONFIG || {};\n\nconst thirdPartyFrameRegex =\n  (typeof env['thirdPartyFrameRegex'] == 'string'\n    ? new RegExp(env['thirdPartyFrameRegex'])\n    : env['thirdPartyFrameRegex']) || /^d-\\d+\\.ampproject\\.net$/;\n\nconst cdnProxyRegex =\n  (typeof env['cdnProxyRegex'] == 'string'\n    ? new RegExp(env['cdnProxyRegex'])\n    : env['cdnProxyRegex']) ||\n  /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/;\n\n/**\n * Check for a custom URL definition in special <meta> tags. Note that this does\n * not allow for distinct custom URLs in AmpDocShadow instances. The shell is\n * allowed to define one set of custom URLs via AMP_CONFIG (recommended) or by\n * including <meta> tags in the shell <head>. Those custom URLs then apply to\n * all AMP documents loaded in the shell.\n * @param {string} name\n * @return {?string}\n * @private\n */\nfunction getMetaUrl(name) {\n  // Avoid exceptions in unit tests\n  if (!self.document || !self.document.head) {\n    return null;\n  }\n\n  // Disallow on proxy origins\n  if (self.location && cdnProxyRegex.test(self.location.origin)) {\n    return null;\n  }\n\n  const metaEl = self.document.head./*OK*/ querySelector(\n    `meta[name=\"${name}\"]`\n  );\n  return (metaEl && metaEl.getAttribute('content')) || null;\n}\n\n/**\n * @typedef {{\n *   thirdParty: string,\n *   thirdPartyFrameHost: string,\n *   thirdPartyFrameRegex: !RegExp,\n *   cdn: string,\n *   cdnProxyRegex: !RegExp,\n *   localhostRegex: !RegExp,\n *   errorReporting: string,\n *   betaErrorReporting: string,\n *   localDev: boolean,\n *   trustedViewerHosts: !Array<!RegExp>,\n *   geoApi: ?string,\n * }}\n */\nexport const urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex,\n  cdn:\n    env['cdnUrl'] || getMetaUrl('runtime-host') || 'https://cdn.ampproject.org',\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting:\n    env['errorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r',\n  betaErrorReporting:\n    env['betaErrorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r-beta',\n  localDev: env['localDev'] || false,\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/main/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [\n    /(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/,\n    /(^|\\.)gmail\\.(com|dev)$/,\n  ],\n  // Optional fallback API if amp-geo is left unpatched\n  geoApi: env['geoApiUrl'] || getMetaUrl('amp-geo-api'),\n};\n\nexport const config = {\n  urls,\n};\n", "/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as assertions from './core/assert/base';\nimport {\n  USER_ERROR_SENTINEL,\n  elementStringOrPassThru,\n  isUserErrorMessage,\n  stripUserError,\n} from './core/error/message-helpers';\nimport {createErrorVargs, duplicateErrorIfNecessary} from './core/error';\nimport {getMode} from './mode';\nimport {internalRuntimeVersion} from './internal-version';\nimport {isArray} from './core/types';\nimport {once} from './core/types/function';\nimport {urls} from './config';\n\nconst noop = () => {};\n\n// These are exported here despite being defined in core to avoid updating\n// imports for now.\nexport {USER_ERROR_SENTINEL, isUserErrorMessage, stripUserError};\n\n/**\n * Four zero width space.\n *\n * @const {string}\n */\nexport const USER_ERROR_EMBED_SENTINEL = '\\u200B\\u200B\\u200B\\u200B';\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\nexport function isUserErrorEmbed(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n\n/**\n * @enum {number}\n */\nexport const LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4,\n};\n\n/**\n * Sets reportError function. Called from error-reporting.js to break cyclic\n * dependency.\n * @param {function(this:Window, Error, (?Element)=): ?|undefined} fn\n */\nexport function setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\nlet levelOverride_ = undefined;\n\n/**\n * @param {!LogLevel} level\n */\nexport function overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\nconst messageUrlRtv = () => `01${internalRuntimeVersion()}`;\n\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\nconst externalMessageUrl = (id, interpolatedParts) =>\n  interpolatedParts.reduce(\n    (prefix, arg) => `${prefix}&s[]=${messageArgToEncodedComponent(arg)}`,\n    `https://log.amp.dev/?v=${messageUrlRtv()}&id=${encodeURIComponent(id)}`\n  );\n\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\nconst externalMessagesSimpleTableUrl = () =>\n  `${urls.cdn}/rtv/${messageUrlRtv()}/log-messages.simple.json`;\n\n/**\n * @param {*} arg\n * @return {string}\n */\nconst messageArgToEncodedComponent = (arg) =>\n  encodeURIComponent(String(elementStringOrPassThru(arg)));\n\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don\u2019t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\nexport class Log {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(number, boolean):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  constructor(win, levelFunc, opt_suffix = '') {\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = getMode().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n\n    /** @private @const {function(number, boolean):!LogLevel} */\n    this.levelFunc_ = levelFunc;\n\n    /** @private @const {!LogLevel} */\n    this.level_ = this.defaultLevel_();\n\n    /** @private @const {string} */\n    this.suffix_ = opt_suffix;\n\n    /** @private {?JsonObject} */\n    this.messages_ = null;\n\n    this.fetchExternalMessagesOnce_ = once(() => {\n      win\n        .fetch(externalMessagesSimpleTableUrl())\n        .then((response) => response.json(), noop)\n        .then((opt_messages) => {\n          if (opt_messages) {\n            this.messages_ = /** @type {!JsonObject} */ (opt_messages);\n          }\n        });\n    });\n\n    // This bound assertion function is capable of handling the format used when\n    // error/assertion messages are extracted. This logic hasn't yet been\n    // migrated to an AMP-independent form for use in core. This binding allows\n    // Log assertion helpers to maintain message-extraction capabilities until\n    // that logic can be moved to core.\n    this.boundAssertFn_ = /** @type {!assertions.AssertionFunctionDef} */ (\n      this.assert.bind(this)\n    );\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  getLevel_() {\n    return levelOverride_ !== undefined ? levelOverride_ : this.level_;\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevel_() {\n    // No console - can't enable logging.\n    if (!this.win.console || !this.win.console.log) {\n      return LogLevel.OFF;\n    }\n\n    // Logging has been explicitly disabled.\n    if (getMode().log == '0') {\n      return LogLevel.OFF;\n    }\n\n    // Logging is enabled for tests directly.\n    if (getMode().test && this.win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    }\n\n    // LocalDev by default allows INFO level, unless overriden by `#log`.\n    if (getMode().localDev && !getMode().log) {\n      return LogLevel.INFO;\n    }\n\n    return this.defaultLevelWithFunc_();\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevelWithFunc_() {\n    // Delegate to the specific resolver.\n    return this.levelFunc_(parseInt(getMode().log, 10), getMode().development);\n  }\n\n  /**\n   * @param {string} tag\n   * @param {!LogLevel} level\n   * @param {!Array} messages\n   * @return {boolean} true if a message was logged\n   */\n  msg_(tag, level, messages) {\n    if (this.getLevel_() < level) {\n      return false;\n    }\n    let fn = this.win.console.log;\n    if (level == LogLevel.ERROR) {\n      fn = this.win.console.error || fn;\n    } else if (level == LogLevel.INFO) {\n      fn = this.win.console.info || fn;\n    } else if (level == LogLevel.WARN) {\n      fn = this.win.console.warn || fn;\n    }\n    const args = this.maybeExpandMessageArgs_(messages);\n    // Prefix console message with \"[tag]\".\n    const prefix = `[${tag}]`;\n    if (typeof args[0] === 'string') {\n      // Prepend string to avoid breaking string substitutions e.g. %s.\n      args[0] = prefix + ' ' + args[0];\n    } else {\n      args.unshift(prefix);\n    }\n    fn.apply(this.win.console, args);\n    return true;\n  }\n\n  /**\n   * Whether the logging is enabled.\n   * @return {boolean}\n   */\n  isEnabled() {\n    return this.getLevel_() != LogLevel.OFF;\n  }\n\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  fine(tag, ...args) {\n    this.msg_(tag, LogLevel.FINE, args);\n  }\n\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  info(tag, ...args) {\n    this.msg_(tag, LogLevel.INFO, args);\n  }\n\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  warn(tag, ...args) {\n    this.msg_(tag, LogLevel.WARN, args);\n  }\n\n  /**\n   * Reports an error message. If the logging is disabled, the error is rethrown\n   * asynchronously.\n   * @param {string} tag\n   * @param {...*} args\n   * @return {!Error|undefined}\n   * @private\n   */\n  error_(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      return this.createError.apply(this, args);\n    }\n  }\n\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  error(tag, var_args) {\n    const error = this.error_.apply(this, arguments);\n    if (error) {\n      // TODO(rcebulko): Determine if/how this Error#name property is used.\n      error.name = tag || error.name;\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} unusedTag\n   * @param {...*} var_args\n   */\n  expectedError(unusedTag, var_args) {\n    const error = this.error_.apply(this, arguments);\n    if (error) {\n      error.expected = true;\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createError(var_args) {\n    const error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    return error;\n  }\n\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createExpectedError(var_args) {\n    const error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    error.expected = true;\n    return error;\n  }\n\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {T} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is falsey.\n   * @template T\n   * @closurePrimitive {asserts.truthy}\n   */\n  assert(shouldBeTrueish, opt_message, var_args) {\n    if (isArray(opt_message)) {\n      return this.assert.apply(\n        this,\n        [shouldBeTrueish].concat(\n          this.expandMessageArgs_(/** @type {!Array} */ (opt_message))\n        )\n      );\n    }\n\n    return assertions.assert.apply(\n      null,\n      [this.suffix_].concat(Array.prototype.slice.call(arguments))\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertElement(shouldBeElement, opt_message) {\n    return assertions.assertElement(\n      this.boundAssertFn_,\n      shouldBeElement,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertString(shouldBeString, opt_message) {\n    return assertions.assertString(\n      this.boundAssertFn_,\n      shouldBeString,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertNumber(shouldBeNumber, opt_message) {\n    return assertions.assertNumber(\n      this.boundAssertFn_,\n      shouldBeNumber,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertArray(shouldBeArray, opt_message) {\n    return assertions.assertArray(\n      this.boundAssertFn_,\n      shouldBeArray,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertBoolean(shouldBeBoolean, opt_message) {\n    return assertions.assertBoolean(\n      this.boundAssertFn_,\n      shouldBeBoolean,\n      opt_message\n    );\n  }\n\n  /**\n   * @param {!Error} error\n   * @private\n   */\n  prepareError_(error) {\n    error = duplicateErrorIfNecessary(error);\n\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = error.message.replace(USER_ERROR_SENTINEL, '');\n    }\n  }\n\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  maybeExpandMessageArgs_(args) {\n    if (isArray(args[0])) {\n      return this.expandMessageArgs_(/** @type {!Array} */ (args[0]));\n    }\n    return args;\n  }\n\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  expandMessageArgs_(parts) {\n    // First value should exist.\n    const id = parts.shift();\n    // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n    if (getMode(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n    if (this.messages_ && id in this.messages_) {\n      return [this.messages_[id]].concat(parts);\n    }\n    return [`More info at ${externalMessageUrl(id, parts)}`];\n  }\n}\n\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null,\n};\n\nconst logs = self.__AMP_LOG;\n\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?typeof Log}\n */\nlet logConstructor = null;\n\n/**\n * Initializes log constructor.\n */\nexport function initLogConstructor() {\n  logConstructor = Log;\n  // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n  dev();\n  user();\n}\n\n/**\n * Resets log constructor for testing.\n */\nexport function resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\nexport function user(opt_element) {\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n  if (!isFromEmbed(logs.user.win, opt_element)) {\n    return logs.user;\n  } else {\n    if (logs.userForEmbed) {\n      return logs.userForEmbed;\n    }\n    return (logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL));\n  }\n}\n\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\nfunction getUserLogger(suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return new logConstructor(\n    self,\n    (logNum, development) => {\n      if (development || logNum >= 1) {\n        return LogLevel.FINE;\n      }\n      return LogLevel.WARN;\n    },\n    suffix\n  );\n}\n\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\nexport function dev() {\n  if (logs.dev) {\n    return logs.dev;\n  }\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return (logs.dev = new logConstructor(self, (logNum) => {\n    if (logNum >= 3) {\n      return LogLevel.FINE;\n    }\n    if (logNum >= 2) {\n      return LogLevel.INFO;\n    }\n    return LogLevel.OFF;\n  }));\n}\n\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\nexport function isFromEmbed(win, opt_element) {\n  if (!opt_element) {\n    return false;\n  }\n  return opt_element.ownerDocument.defaultView != win;\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (getMode().minified) {\n    return shouldBeTrueish;\n  }\n  if (self.__AMP_ASSERTION_CHECK) {\n    // This will never execute regardless, but will be included on unminified\n    // builds. It will be DCE'd away from minified builds, and so can be used to\n    // validate that Babel is properly removing dev assertions in minified\n    // builds.\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n\n  return dev()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function userAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return user()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n", "/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Registration and getter functions for AMP services.\n *\n * Invariant: Service getters never return null for registered services.\n */\n\nimport {Deferred} from './core/data-structures/promise';\nimport {dev, devAssert} from './log';\nimport {toWin} from './core/window';\n\n/**\n * Holds info about a service.\n * - obj: Actual service implementation when available.\n * - promise: Promise for the obj.\n * - resolve: Function to resolve the promise with the object.\n * - context: Argument for ctor, either a window or an ampdoc.\n * - ctor: Function that constructs and returns the service.\n * @typedef {{\n *   obj: (?Object),\n *   promise: (?Promise),\n *   resolve: (?function(!Object)),\n *   reject: (?function((*))),\n *   context: (?Window|?./service/ampdoc-impl.AmpDoc),\n *   ctor: (function(new:Object, !Window)|\n *          function(new:Object, !./service/ampdoc-impl.AmpDoc)),\n * }}\n */\nlet ServiceHolderDef;\n\n/**\n * This interface provides a `dispose` method that will be called by\n * runtime when a service needs to be disposed of.\n * @interface\n */\nexport class Disposable {\n  /**\n   * Instructs the service to release any resources it might be holding. Can\n   * be called only once in the lifecycle of a service.\n   */\n  dispose() {}\n}\n\n/**\n * Installs a service override on amp-doc level.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n * @param {!Object} service The service.\n */\nexport function installServiceInEmbedDoc(ampdoc, id, service) {\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ true\n  );\n}\n\n/**\n * Installs a service override in the scope of an embedded window.\n * @param {!Window} embedWin\n * @param {string} id\n * @param {function(new:Object, !Window)} constructor\n */\nexport function registerServiceBuilderInEmbedWin(embedWin, id, constructor) {\n  registerServiceInternal(\n    embedWin,\n    embedWin,\n    id,\n    constructor,\n    /* override */ true\n  );\n}\n\n/**\n * Registers a service given a class to be used as implementation.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {function(new:Object, !Window)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilder(win, id, constructor, opt_instantiate) {\n  win = getTopWindow(win);\n  registerServiceInternal(win, win, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(win, id);\n  }\n}\n\n/**\n * Returns a service and registers it given a class to be used as\n * implementation.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id of the service.\n * @param {function(new:Object, !./service/ampdoc-impl.AmpDoc)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilderForDoc(\n  nodeOrDoc,\n  id,\n  constructor,\n  opt_instantiate\n) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  registerServiceInternal(holder, ampdoc, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * Reject a service promise.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id\n * @param {*} error\n */\nexport function rejectServicePromiseForDoc(nodeOrDoc, id, error) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  rejectServicePromiseInternal(holder, id, error);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). Users\n * should typically wrap this as a special purpose function (e.g.\n * `Services.vsyncFor(win)`) for type safety and because the factory should not\n * be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getService(win, id) {\n  win = getTopWindow(win);\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). But\n * it looks in the immediate window scope, not the top-level window.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getServiceInEmbedWin(win, id) {\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. `Services.vsyncFor(win)`) for type safety and because the\n * factory should not be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nexport function getServicePromise(win, id) {\n  return getServicePromiseInternal(win, id);\n}\n\n/**\n * Returns a service or null with the given id.\n * @param {!Window} win\n * @param {string} id\n * @return {?Object} The service.\n */\nexport function getExistingServiceOrNull(win, id) {\n  win = getTopWindow(win);\n  if (isServiceRegistered(win, id)) {\n    return getServiceInternal(win, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Like getServicePromise but returns null if the service was never registered.\n * @param {!Window} win\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNull(win, id) {\n  return getServicePromiseOrNullInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * Expects service `id` to be registered.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {T}\n * @template T\n */\nexport function getServiceForDoc(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  return getServiceInternal(holder, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * If service `id` is not registered, returns null.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Object}\n */\nexport function getServiceForDocOrNull(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  if (isServiceRegistered(holder, id)) {\n    return getServiceInternal(holder, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Returns a promise for a service for the given id and ampdoc. Also expects\n * a service that has the actual implementation. The promise resolves when\n * the implementation loaded.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {!Promise<!Object>}\n */\nexport function getServicePromiseForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseInternal(getAmpdocServiceHolder(elementOrAmpDoc), id);\n}\n\n/**\n * Like getServicePromiseForDoc but returns null if the service was never\n * registered for this ampdoc.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNullForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseOrNullInternal(\n    getAmpdocServiceHolder(elementOrAmpDoc),\n    id\n  );\n}\n\n/**\n * Set the parent and top windows on a child window (friendly iframe).\n * @param {!Window} win\n * @param {!Window} parentWin\n */\nexport function setParentWindow(win, parentWin) {\n  win.__AMP_PARENT = parentWin;\n  win.__AMP_TOP = getTopWindow(parentWin);\n}\n\n/**\n * Returns the parent window for a child window (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getParentWindow(win) {\n  return win.__AMP_PARENT || win;\n}\n\n/**\n * Returns the top window where AMP Runtime is installed for a child window\n * (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getTopWindow(win) {\n  return win.__AMP_TOP || (win.__AMP_TOP = win);\n}\n\n/**\n * Returns the parent \"friendly\" iframe if the node belongs to a child window.\n * @param {!Node} node\n * @param {!Window=} opt_topWin\n * @return {?HTMLIFrameElement}\n */\nexport function getParentWindowFrameElement(node, opt_topWin) {\n  const childWin = (node.ownerDocument || node).defaultView;\n  const topWin = opt_topWin || getTopWindow(childWin);\n  if (childWin && childWin != topWin && getTopWindow(childWin) == topWin) {\n    try {\n      return /** @type {?HTMLIFrameElement} */ (childWin.frameElement);\n    } catch (e) {\n      // Ignore the error.\n    }\n  }\n  return null;\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc}\n */\nexport function getAmpdoc(nodeOrDoc) {\n  if (nodeOrDoc.nodeType) {\n    const win = toWin(\n      /** @type {!Document} */ (nodeOrDoc.ownerDocument || nodeOrDoc)\n        .defaultView\n    );\n    return getAmpdocService(win).getAmpDoc(/** @type {!Node} */ (nodeOrDoc));\n  }\n  return /** @type {!./service/ampdoc-impl.AmpDoc} */ (nodeOrDoc);\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc|!Window}\n */\nfunction getAmpdocServiceHolder(nodeOrDoc) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  return ampdoc.isSingleDoc() ? ampdoc.win : ampdoc;\n}\n\n/**\n * This is essentially a duplicate of `ampdoc.js`, but necessary to avoid\n * circular dependencies.\n * @param {!Window} win\n * @return {!./service/ampdoc-impl.AmpDocService}\n */\nfunction getAmpdocService(win) {\n  return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n    getService(win, 'ampdoc')\n  );\n}\n\n/**\n * Get service `id` from `holder`. Assumes the service\n * has already been registered.\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {Object}\n */\nfunction getServiceInternal(holder, id) {\n  devAssert(\n    isServiceRegistered(holder, id),\n    `Expected service ${id} to be registered`\n  );\n  const services = getServices(holder);\n  const s = services[id];\n  if (!s.obj) {\n    devAssert(s.ctor, `Service ${id} registered without ctor nor impl.`);\n    devAssert(s.context, `Service ${id} registered without context.`);\n    s.obj = new s.ctor(s.context);\n    devAssert(s.obj, `Service ${id} constructed to null.`);\n    s.context = null;\n    // The service may have been requested already, in which case we have a\n    // pending promise we need to fulfill.\n    if (s.resolve) {\n      s.resolve(s.obj);\n    }\n  }\n  return s.obj;\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {!Window|!./service/ampdoc-impl.AmpDoc} context Win or AmpDoc.\n * @param {string} id of the service.\n * @param {?function(new:Object, !Window)|?function(new:Object, !./service/ampdoc-impl.AmpDoc)} ctor Constructor function to new the service. Called with context.\n * @param {boolean=} opt_override\n * @param {boolean=} opt_sharedInstance\n */\nfunction registerServiceInternal(\n  holder,\n  context,\n  id,\n  ctor,\n  opt_override,\n  opt_sharedInstance\n) {\n  const services = getServices(holder);\n  let s = services[id];\n\n  if (!s) {\n    s = services[id] = {\n      obj: null,\n      promise: null,\n      resolve: null,\n      reject: null,\n      context: null,\n      ctor: null,\n      sharedInstance: opt_sharedInstance || false,\n    };\n  }\n\n  if (!opt_override && s.ctor) {\n    // Service already registered.\n    return;\n  }\n\n  s.ctor = ctor;\n  s.context = context;\n  s.sharedInstance = opt_sharedInstance || false;\n\n  // The service may have been requested already, in which case there is a\n  // pending promise that needs to fulfilled.\n  if (s.resolve) {\n    // getServiceInternal will resolve the promise.\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nfunction getServicePromiseInternal(holder, id) {\n  const cached = getServicePromiseOrNullInternal(holder, id);\n  if (cached) {\n    return cached;\n  }\n  // Service is not registered.\n\n  // TODO(@cramforce): Add a check that if the element is eventually registered\n  // that the service is actually provided and this promise resolves.\n  const services = getServices(holder);\n  services[id] = emptyServiceHolderWithPromise();\n  return /** @type {!Promise<!Object>} */ (services[id].promise);\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @param {*} error\n */\nfunction rejectServicePromiseInternal(holder, id, error) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.reject) {\n      s.reject(error);\n    }\n    return;\n  }\n\n  services[id] = emptyServiceHolderWithPromise();\n  services[id].reject(error);\n}\n\n/**\n * Returns a promise for service `id` if the service has been registered\n * on `holder`.\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {?Promise<!Object>}\n */\nfunction getServicePromiseOrNullInternal(holder, id) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.promise) {\n      return s.promise;\n    } else {\n      // Instantiate service if not already instantiated.\n      getServiceInternal(holder, id);\n      return (s.promise = Promise.resolve(/** @type {!Object} */ (s.obj)));\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the object that holds the services registered in a holder.\n * @param {!Object} holder\n * @return {!Object<string,!ServiceHolderDef>}\n */\nfunction getServices(holder) {\n  let services = holder.__AMP_SERVICES;\n  if (!services) {\n    services = holder.__AMP_SERVICES = {};\n  }\n  return services;\n}\n\n/**\n * Whether the specified service implements `Disposable` interface.\n * @param {!Object} service\n * @return {boolean}\n */\nexport function isDisposable(service) {\n  return typeof service.dispose == 'function';\n}\n\n/**\n * Asserts that the specified service implements `Disposable` interface and\n * typecasts the instance to `Disposable`.\n * @param {!Object} service\n * @return {!Disposable}\n */\nexport function assertDisposable(service) {\n  devAssert(isDisposable(service), 'required to implement Disposable');\n  return /** @type {!Disposable} */ (service);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * ampdoc scope.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n */\nexport function disposeServicesForDoc(ampdoc) {\n  disposeServicesInternal(ampdoc);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * embed scope.\n * @param {!Window} embedWin\n */\nexport function disposeServicesForEmbed(embedWin) {\n  disposeServicesInternal(embedWin);\n}\n\n/**\n * @param {!Object} holder Object holding the service instances.\n */\nfunction disposeServicesInternal(holder) {\n  const services = getServices(holder);\n  for (const id in services) {\n    if (!Object.prototype.hasOwnProperty.call(services, id)) {\n      continue;\n    }\n    const serviceHolder = services[id];\n    if (serviceHolder.sharedInstance) {\n      continue;\n    }\n    if (serviceHolder.obj) {\n      disposeServiceInternal(id, serviceHolder.obj);\n    } else if (serviceHolder.promise) {\n      serviceHolder.promise.then((instance) =>\n        disposeServiceInternal(id, instance)\n      );\n    }\n  }\n}\n\n/**\n * @param {string} id\n * @param {!Object} service\n */\nfunction disposeServiceInternal(id, service) {\n  if (!isDisposable(service)) {\n    return;\n  }\n  try {\n    assertDisposable(service).dispose();\n  } catch (e) {\n    // Ensure that a failure to dispose a service does not disrupt other\n    // services.\n    dev().error('SERVICE', 'failed to dispose service', id, e);\n  }\n}\n\n/**\n * This adopts the service **instance** from the parent.\n *\n * This function is dangerous! Sharing an instance means data can leak to and\n * from a child ampdoc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceForEmbedDoc(ampdoc, id) {\n  const service = getServiceInternal(\n    getAmpdocServiceHolder(devAssert(ampdoc.getParent())),\n    id\n  );\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ false,\n    /* sharedInstance */ true\n  );\n}\n\n/**\n * This adopts the service **factory** from the parent.\n *\n * This function is safer than sharing the service instance, since each ampdoc\n * will create its own instance of the factory (and each instance will have its\n * own instance data). Note that static data is still shared, so it's not 100%\n * foolproof.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceFactoryForEmbedDoc(ampdoc, id) {\n  const parentHolder = getAmpdocServiceHolder(devAssert(ampdoc.getParent()));\n  devAssert(\n    isServiceRegistered(parentHolder, id),\n    `Expected service ${id} to be registered`\n  );\n  const service = getServices(parentHolder)[id];\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    devAssert(service.ctor)\n  );\n}\n\n/**\n * Resets a single service, so it gets recreated on next getService invocation.\n * @param {!Object} holder\n * @param {string} id of the service.\n */\nexport function resetServiceForTesting(holder, id) {\n  if (holder.__AMP_SERVICES) {\n    holder.__AMP_SERVICES[id] = null;\n  }\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {boolean}\n */\nfunction isServiceRegistered(holder, id) {\n  const service = holder.__AMP_SERVICES && holder.__AMP_SERVICES[id];\n  // All registered services must have a constructor.\n  return !!(service && service.ctor);\n}\n\n/** @return {!ServiceHolderDef} */\nfunction emptyServiceHolderWithPromise() {\n  const deferred = new Deferred();\n  const {promise, reject, resolve} = deferred;\n  promise.catch(() => {}); // avoid uncaught exception when service gets rejected\n  return {\n    obj: null,\n    promise,\n    resolve,\n    reject,\n    context: null,\n    ctor: null,\n  };\n}\n", "/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * See https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\n *\n * This is the stub to support ResizeObserver. It's installed from\n * polyfills/resize-observer.js and upgraded from the\n * amp-resize-observer-polyfill extension.\n */\n\n/** @typedef {function(!typeof ResizeObserver)} */\nlet ResObsUpgraderDef;\n\nconst UPGRADERS = '_upgraders';\nconst STUB = '_stub';\n\n/**\n * @param {!Window} win\n * @return {boolean}\n * @visibleForTesting\n */\nexport function shouldLoadPolyfill(win) {\n  return !win.ResizeObserver || !!win.ResizeObserver[STUB];\n}\n\n/**\n * Installs the ResOb stubs.\n *\n * @param {!Window} win\n */\nexport function installStub(win) {\n  if (win.ResizeObserver) {\n    return;\n  }\n\n  win.ResizeObserver = ResizeObserverStub;\n  win.ResizeObserver[STUB] = ResizeObserverStub;\n}\n\n/**\n * @param {!Window} win\n * @param {function()} installer\n */\nexport function upgradePolyfill(win, installer) {\n  // Can't use the ResizeObserverStub here directly since it's a separate\n  // instance deployed in v0.js vs the polyfill extension.\n  const Stub = win.ResizeObserver[STUB];\n  if (Stub) {\n    delete win.ResizeObserver;\n    delete win.ResizeObserverEntry;\n    installer();\n\n    const Polyfill = win.ResizeObserver;\n    /** @type {!Array<ResObsUpgraderDef>} */\n    const upgraders = Stub[UPGRADERS].slice(0);\n    const microtask = Promise.resolve();\n    const upgrade = (upgrader) => {\n      microtask.then(() => upgrader(Polyfill));\n    };\n    for (const upgrader of upgraders) {\n      upgrade(upgrader);\n    }\n    Stub[UPGRADERS] = {'push': upgrade};\n  } else {\n    // Even if this is not the stub, we still may need to install the polyfill.\n    // See `shouldLoadPolyfill` for more info.\n    installer();\n  }\n}\n\n/**\n * The stub for `ResizeObserver`. Implements the same interface, but\n * keeps the tracked elements in memory until the actual polyfill arives.\n * This stub is necessary because the polyfill itself is significantly bigger.\n * It doesn't technically extend ResizeObserver, but this allows the stub\n * to be seen as equivalent when typechecking calls expecting a ResizeObserver.\n * @extends ResizeObserver\n */\nexport class ResizeObserverStub {\n  /** @param {!ResizeObserverCallback} callback */\n  constructor(callback) {\n    /** @private @const {!ResizeObserverCallback} */\n    this.callback_ = callback;\n\n    /** @private {!Array<!Element>} */\n    this.elements_ = [];\n\n    /** @private {?ResizeObserver} */\n    this.inst_ = null;\n\n    // Wait for the upgrade.\n    ResizeObserverStub[UPGRADERS].push(this.upgrade_.bind(this));\n  }\n\n  /** @return {undefined} */\n  disconnect() {\n    if (this.inst_) {\n      this.inst_.disconnect();\n    } else {\n      this.elements_.length = 0;\n    }\n  }\n\n  /** @param {!Element} target */\n  observe(target) {\n    if (this.inst_) {\n      this.inst_.observe(target);\n    } else {\n      if (this.elements_.indexOf(target) == -1) {\n        this.elements_.push(target);\n      }\n    }\n  }\n\n  /** @param {!Element} target */\n  unobserve(target) {\n    if (this.inst_) {\n      this.inst_.unobserve(target);\n    } else {\n      const index = this.elements_.indexOf(target);\n      if (index != -1) {\n        this.elements_.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * @param {!typeof ResizeObserver} Ctor\n   * @private\n   */\n  upgrade_(Ctor) {\n    const inst = new Ctor(this.callback_);\n    this.inst_ = inst;\n    for (const e of this.elements_) {\n      inst.observe(e);\n    }\n    this.elements_.length = 0;\n  }\n}\n\n/** @type {!Array<!ResObsUpgraderDef>} */\nResizeObserverStub[UPGRADERS] = [];\n\n/** @visibleForTesting */\nexport function resetStubsForTesting() {\n  ResizeObserverStub[UPGRADERS] = [];\n}\n", "/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {installResizeObserver} from '../../../third_party/resize-observer-polyfill/ResizeObserver.install';\nimport {registerServiceBuilder} from '../../../src/service';\nimport {upgradePolyfill} from '../../../src/polyfills/stubs/resize-observer-stub';\n\nconst TAG = 'amp-resize-observer-polyfill';\n\n/**\n * @param {!Window} win\n * @return {!Object}\n */\nfunction upgrade(win) {\n  upgradePolyfill(win, () => {\n    installResizeObserver(win);\n  });\n  return {};\n}\n\n/**\n * Registers the polyfill.\n * @param {!Window} win\n */\nexport function upgradeResizeObserverPolyfill(win) {\n  registerServiceBuilder(win, TAG, upgrade, /* instantiate */ true);\n}\n\n// eslint-disable-next-line no-unused-vars\nAMP.extension(TAG, '0.1', function (AMP) {\n  upgradeResizeObserverPolyfill(window);\n});\n"],
  "mappings": ";;;;AAAO,iCAA+B,QAAQ;AAC7C,IAAA,UAAU,SAAQ,SAAS;AACvB,cAAO,iBAAiB;OAC3B,QAAS,WAAY;AAAE;AASrB,UAAI,UAAW,WAAY;AACvB,YAAI,OAAO,QAAQ,aAAa;AAC5B,iBAAO;;AASX,0BAAkB,KAAK,KAAK;AACxB,cAAI,SAAS;AACb,cAAI,KAAK,SAAU,OAAO,QAAO;AAC7B,gBAAI,MAAM,OAAO,KAAK;AAClB,uBAAS;AACT,qBAAO;;AAEX,mBAAO;;AAEX,iBAAO;;AAEX,eAAsB,WAAY;AAC9B,6BAAmB;AACf,iBAAK,cAAc;;AAEvB,iBAAO,eAAe,QAAQ,WAAW,QAAQ;YAI7C,KAAK,eAAY;AACb,qBAAO,KAAK,YAAY;;YAE5B,YAAY;YACZ,cAAc;;AAMlB,kBAAQ,UAAU,MAAM,SAAU,KAAK;AACnC,gBAAI,SAAQ,SAAS,KAAK,aAAa;AACvC,gBAAI,QAAQ,KAAK,YAAY;AAC7B,mBAAO,SAAS,MAAM;;AAO1B,kBAAQ,UAAU,MAAM,SAAU,KAAK,OAAO;AAC1C,gBAAI,SAAQ,SAAS,KAAK,aAAa;AACvC,gBAAI,CAAC,QAAO;AACR,mBAAK,YAAY,QAAO,KAAK;mBAE5B;AACD,mBAAK,YAAY,KAAK,CAAC,KAAK;;;AAOpC,kBAAQ,UAAU,SAAS,SAAU,KAAK;AACtC,gBAAI,UAAU,KAAK;AACnB,gBAAI,SAAQ,SAAS,SAAS;AAC9B,gBAAI,CAAC,QAAO;AACR,sBAAQ,OAAO,QAAO;;;AAO9B,kBAAQ,UAAU,MAAM,SAAU,KAAK;AACnC,mBAAO,CAAC,CAAC,CAAC,SAAS,KAAK,aAAa;;AAKzC,kBAAQ,UAAU,QAAQ,WAAY;AAClC,iBAAK,YAAY,OAAO;;AAO5B,kBAAQ,UAAU,UAAU,SAAU,UAAU,KAAK;AACjD,gBAAI,QAAQ,QAAQ;AAAE,oBAAM;;AAC5B,qBAAS,KAAK,GAAG,KAAK,KAAK,aAAa,KAAK,GAAG,QAAQ,MAAM;AAC1D,kBAAI,QAAQ,GAAG;AACf,uBAAS,KAAK,KAAK,MAAM,IAAI,MAAM;;;AAG3C,iBAAO;;;AAWf,UAAI,qBAAsB,6BAAU,QAAQ,OAAO;AAC/C,iBAAS,KAAK,GAAG,KAAK,OAAO,KAAK,QAAQ,KAAK,GAAG,QAAQ,MAAM;AAC5D,cAAI,MAAM,GAAG;AACb,iBAAO,eAAe,QAAQ,KAAK;YAC/B,OAAO,MAAM;YACb,YAAY;YACZ,UAAU;YACV,cAAc;;;AAGtB,eAAO;;AAIX,UAAI,WAAY,WAAY;AACxB,YAAI,OAAO,WAAW,eAAe,OAAO,SAAS,MAAM;AACvD,iBAAO;;AAEX,YAAI,OAAO,SAAS,eAAe,KAAK,SAAS,MAAM;AACnD,iBAAO;;AAEX,YAAI,OAAO,WAAW,eAAe,OAAO,SAAS,MAAM;AACvD,iBAAO;;AAGX,eAAO,SAAS;;AASpB,UAAI,cAAe,sBAAU,QAAQ;AAIjC,YAAI,cAAc,UAAU,OAAO,iBAAiB,OAAO,cAAc;AAGzE,eAAO,eAAe;;AAM1B,UAAI,YAAY,OAAO,WAAW,eAAe,OAAO,aAAa,eAAe,OAAO,aAAa;AAGxG,UAAI,YAAY,eAAe,GAAG,GAAG,GAAG;AAOxC,uBAAiB,OAAO;AACpB,eAAO,WAAW,UAAU;;AAShC,8BAAwB,QAAQ;AAC5B,YAAI,YAAY;AAChB,iBAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,oBAAU,KAAK,KAAK,UAAU;;AAElC,eAAO,UAAU,OAAO,SAAU,MAAM,UAAU;AAC9C,cAAI,QAAQ,OAAO,YAAY,WAAW;AAC1C,iBAAO,OAAO,QAAQ;WACvB;;AAQP,2BAAqB,QAAQ;AACzB,YAAI,YAAY,CAAC,OAAO,SAAS,UAAU;AAC3C,YAAI,WAAW;AACf,iBAAS,KAAK,GAAG,cAAc,WAAW,KAAK,YAAY,QAAQ,MAAM;AACrE,cAAI,WAAW,YAAY;AAC3B,cAAI,QAAQ,OAAO,aAAa;AAChC,mBAAS,YAAY,QAAQ;;AAEjC,eAAO;;AASX,iCAA2B,QAAQ;AAC/B,YAAI,OAAO,OAAO;AAClB,eAAO,eAAe,GAAG,GAAG,KAAK,OAAO,KAAK;;AAQjD,yCAAmC,QAAQ;AAGvC,YAAI,cAAc,OAAO,aAAa,eAAe,OAAO;AAS5D,YAAI,CAAC,eAAe,CAAC,cAAc;AAC/B,iBAAO;;AAEX,YAAI,SAAS,YAAY,QAAQ,iBAAiB;AAClD,YAAI,WAAW,YAAY;AAC3B,YAAI,WAAW,SAAS,OAAO,SAAS;AACxC,YAAI,UAAU,SAAS,MAAM,SAAS;AAKtC,YAAI,QAAQ,QAAQ,OAAO,QAAQ,SAAS,QAAQ,OAAO;AAG3D,YAAI,OAAO,cAAc,cAAc;AAOnC,cAAI,KAAK,MAAM,QAAQ,cAAc,aAAa;AAC9C,qBAAS,eAAe,QAAQ,QAAQ,WAAW;;AAEvD,cAAI,KAAK,MAAM,SAAS,aAAa,cAAc;AAC/C,sBAAU,eAAe,QAAQ,OAAO,YAAY;;;AAO5D,YAAI,CAAC,kBAAkB,SAAS;AAK5B,cAAI,gBAAgB,KAAK,MAAM,QAAQ,YAAY;AACnD,cAAI,iBAAiB,KAAK,MAAM,SAAS,WAAW;AAMpD,cAAI,KAAK,IAAI,mBAAmB,GAAG;AAC/B,qBAAS;;AAEb,cAAI,KAAK,IAAI,oBAAoB,GAAG;AAChC,sBAAU;;;AAGlB,eAAO,eAAe,SAAS,MAAM,SAAS,KAAK,OAAO;;AAQ9D,UAAI,uBAAwB,WAAY;AAGpC,YAAI,OAAO,uBAAuB,aAAa;AAC3C,iBAAO,SAAU,QAAQ;AAAE,mBAAO,kBAAkB,YAAY,QAAQ;;;AAK5E,eAAO,SAAU,QAAQ;AAAE,iBAAQ,kBAAkB,YAAY,QAAQ,cACrE,OAAO,OAAO,YAAY;;;AAQlC,iCAA2B,QAAQ;AAC/B,eAAO,WAAW,YAAY,QAAQ,SAAS;;AAQnD,8BAAwB,QAAQ;AAC5B,YAAI,CAAC,WAAW;AACZ,iBAAO;;AAEX,YAAI,qBAAqB,SAAS;AAC9B,iBAAO,kBAAkB;;AAE7B,eAAO,0BAA0B;;AASrC,kCAA4B,IAAI;AAC5B,YAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,QAAQ,GAAG,OAAO,SAAS,GAAG;AAEtD,YAAI,SAAS,OAAO,oBAAoB,cAAc,kBAAkB;AACxE,YAAI,OAAO,OAAO,OAAO,OAAO;AAEhC,2BAAmB,MAAM;UACrB;UAAM;UAAM;UAAc;UAC1B,KAAK;UACL,OAAO,IAAI;UACX,QAAQ,SAAS;UACjB,MAAM;;AAEV,eAAO;;AAYX,8BAAwB,GAAG,GAAG,OAAO,QAAQ;AACzC,eAAO;UAAE;UAAM;UAAM;UAAc;;;AAOvC,UAAI,oBAAmC,WAAY;AAQ/C,oCAA2B,QAAQ,UAAU;AAMzC,eAAK,iBAAiB;AAMtB,eAAK,kBAAkB;AAMvB,eAAK,eAAe,eAAe,GAAG,GAAG,GAAG;AAC5C,eAAK,SAAS;AACd,eAAK,WAAW;;AAQpB,2BAAkB,UAAU,WAAW,WAAY;AAC/C,cAAI,OAAO,eAAe,KAAK;AAC/B,eAAK,eAAe;AACpB,iBAAQ,KAAK,UAAU,KAAK,kBACxB,KAAK,WAAW,KAAK;;AAQ7B,2BAAkB,UAAU,gBAAgB,WAAY;AACpD,cAAI,OAAO,KAAK;AAChB,eAAK,iBAAiB,KAAK;AAC3B,eAAK,kBAAkB,KAAK;AAC5B,iBAAO;;AAEX,eAAO;;AAGX,UAAI,sBAAqC,WAAY;AAOjD,sCAA6B,QAAQ,UAAU;AAC3C,cAAI,cAAc,mBAAmB;AAOrC,6BAAmB,MAAM;YAAE;YAAgB;;;AAE/C,eAAO;;AAYX,2BAAqB,MAAM;AACvB,YAAI,OAAO,KAAK,gBAAgB,YAAY;AACxC,iBAAO,KAAK;;AAEhB,YAAI;AAEJ,aAAK,IAAI,MAAM,EAAE,YAAY,IAAI,EAAE,YAAY;;AAC/C,eAAO;;AAIX,UAAI,gCAAgC,OAAO,yBAAyB;AACpE,UAAI,oBAAmC,WAAY;AAW/C,oCAA2B,UAAU,YAAY,aAAa;AAC1D,cAAI,QAAQ;AAOZ,eAAK,sBAAsB;AAM3B,eAAK,gBAAgB,IAAI;AAOzB,eAAK,aAAa,IAAI;AAUtB,eAAK,wBAAwB;AAC7B,cAAI,OAAO,aAAa,YAAY;AAChC,kBAAM,IAAI,UAAU;;AAExB,eAAK,YAAY;AACjB,eAAK,cAAc;AACnB,eAAK,eAAe;AACpB,cAAI,+BAA+B;AAC/B,iBAAK,wBAAwB,IAAI,qBAAqB,WAAY;AAAE,qBAAO,MAAM;;;;AASzF,2BAAkB,UAAU,UAAU,SAAU,QAAQ;AACpD,cAAI,CAAC,UAAU,QAAQ;AACnB,kBAAM,IAAI,UAAU;;AAGxB,cAAI,OAAO,YAAY,eAAe,CAAE,oBAAmB,SAAS;AAChE;;AAEJ,cAAI,CAAE,mBAAkB,YAAY,QAAQ,UAAU;AAClD,kBAAM,IAAI,UAAU;;AAExB,cAAI,eAAe,KAAK;AAExB,cAAI,aAAa,IAAI,SAAS;AAC1B;;AAEJ,cAAI,WAAW,sBAAsB,QAAQ,OAAO;AACpD,uBAAa,IAAI,QAAQ,IAAI,kBAAkB,QAAQ;AACvD,cAAI,kBAAkB,KAAK,WAAW,IAAI;AAC1C,cAAI,CAAC,iBAAiB;AAClB,8BAAkB;AAClB,iBAAK,WAAW,IAAI,UAAU;AAC9B,iBAAK,YAAY,YAAY,UAAU;;AAE3C,0BAAgB,KAAK;AACrB,cAAI,KAAK,uBAAuB;AAC5B,iBAAK,sBAAsB,QAAQ;;AAGvC,eAAK,YAAY,QAAQ;;AAQ7B,2BAAkB,UAAU,YAAY,SAAU,QAAQ;AACtD,cAAI,CAAC,UAAU,QAAQ;AACnB,kBAAM,IAAI,UAAU;;AAGxB,cAAI,OAAO,YAAY,eAAe,CAAE,oBAAmB,SAAS;AAChE;;AAEJ,cAAI,CAAE,mBAAkB,YAAY,QAAQ,UAAU;AAClD,kBAAM,IAAI,UAAU;;AAExB,cAAI,eAAe,KAAK;AACxB,cAAI,cAAc,aAAa,IAAI;AAEnC,cAAI,CAAC,aAAa;AACd;;AAEJ,uBAAa,OAAO;AACpB,cAAI,KAAK,uBAAuB;AAC5B,iBAAK,sBAAsB,UAAU;;AAGzC,cAAI,WAAW,YAAY;AAC3B,cAAI,kBAAkB,KAAK,WAAW,IAAI;AAC1C,cAAI,iBAAiB;AACjB,gBAAI,SAAQ,gBAAgB,QAAQ;AACpC,gBAAI,CAAC,QAAO;AACR,8BAAgB,OAAO,QAAO;;AAElC,gBAAI,gBAAgB,WAAW,GAAG;AAC9B,mBAAK,WAAW,OAAO;AACvB,mBAAK,YAAY,eAAe,UAAU;;;;AAStD,2BAAkB,UAAU,aAAa,WAAY;AACjD,cAAI,QAAQ;AACZ,eAAK;AACL,eAAK,cAAc;AACnB,eAAK,WAAW,QAAQ,SAAU,GAAG,UAAU;AAC3C,kBAAM,YAAY,eAAe,UAAU;;AAE/C,eAAK,WAAW;AAChB,cAAI,KAAK,uBAAuB;AAC5B,iBAAK,sBAAsB;AAC3B,iBAAK,wBAAwB;;;AASrC,2BAAkB,UAAU,eAAe,WAAY;AACnD,cAAI,QAAQ;AACZ,eAAK;AACL,eAAK;AACL,eAAK,cAAc,QAAQ,SAAU,aAAa;AAC9C,gBAAI,YAAY,YAAY;AACxB,oBAAM,oBAAoB,KAAK;;;;AAU3C,2BAAkB,UAAU,kBAAkB,WAAY;AAEtD,cAAI,CAAC,KAAK,aAAa;AACnB;;AAEJ,cAAI,MAAM,KAAK;AAEf,cAAI,UAAU,KAAK,oBAAoB,IAAI,SAAU,aAAa;AAC9D,mBAAO,IAAI,oBAAoB,YAAY,QAAQ,YAAY;;AAEnE,eAAK,UAAU,KAAK,KAAK,SAAS;AAClC,eAAK;;AAOT,2BAAkB,UAAU,cAAc,WAAY;AAClD,eAAK,oBAAoB,OAAO;;AAOpC,2BAAkB,UAAU,YAAY,WAAY;AAChD,iBAAO,KAAK,oBAAoB,SAAS;;AAS7C,2BAAkB,UAAU,oBAAoB,WAAY;AACxD,cAAI,QAAQ;AACZ,cAAI,qBAAqB;AACzB,eAAK,cAAc,QAAQ,SAAU,aAAa;AAC9C,gBAAI,SAAS,YAAY,QAAQ,cAAc,YAAY;AAC3D,gBAAI,WAAW,sBAAsB,QAAQ;AAC7C,gBAAI,aAAa,aAAa;AAC1B,kBAAI,CAAC,oBAAoB;AACrB,qCAAqB;;AAEzB,iCAAmB,KAAK;;;AAGhC,cAAI,oBAAoB;AACpB,+BAAmB,QAAQ,SAAU,QAAQ;AACzC,oBAAM,UAAU;AAChB,oBAAM,QAAQ;;;;AAI1B,eAAO;;AAUX,qCAA+B,QAAQ,KAAK;AACxC,YAAI,WAAW,YAAY;AAG3B,YAAI,SAAS,aAAa,KACtB,SAAS,aAAa,IAAI;AAC1B,iBAAO;;AAEX,eAAO;;AASX,UAAI,0BAA2B,WAAY;AACvC,YAAI,OAAO,0BAA0B,YAAY;AAI7C,iBAAO,sBAAsB,KAAK;;AAEtC,eAAO,SAAU,UAAU;AAAE,iBAAO,WAAW,WAAY;AAAE,mBAAO,SAAS,KAAK;aAAW,MAAO;;;AAIxG,UAAI,kBAAkB;AAStB,wBAAmB,UAAU,OAAO;AAChC,YAAI,cAAc,OAAO,eAAe,OAAO,eAAe;AAO9D,kCAA0B;AACtB,cAAI,aAAa;AACb,0BAAc;AACd;;AAEJ,cAAI,cAAc;AACd;;;AAUR,mCAA2B;AACvB,kCAAwB;;AAO5B,yBAAiB;AACb,cAAI,YAAY,KAAK;AACrB,cAAI,aAAa;AAEb,gBAAI,YAAY,eAAe,iBAAiB;AAC5C;;AAMJ,2BAAe;iBAEd;AACD,0BAAc;AACd,2BAAe;AACf,uBAAW,iBAAiB;;AAEhC,yBAAe;;AAEnB,eAAO;;AAIX,UAAI,gBAAgB;AAGpB,UAAI,iBAAiB,CAAC,OAAO,SAAS,UAAU,QAAQ,SAAS,UAAU,QAAQ;AAEnF,UAAI,4BAA4B,OAAO,qBAAqB;AAO5D,UAAI,2BAA0C,WAAY;AAStD,2CAAkC,UAAU,kBAAkB;AAM1D,eAAK,YAAY;AAMjB,eAAK,oBAAoB;AAMzB,eAAK,aAAa;AAMlB,eAAK,uBAAuB;AAM5B,eAAK,qBAAqB;AAM1B,eAAK,gBAAgB;AAMrB,eAAK,aAAa;AAClB,eAAK,YAAY;AACjB,eAAK,oBAAoB;AACzB,eAAK,mBAAmB,KAAK,iBAAiB,KAAK;AACnD,eAAK,UAAU,SAAS,KAAK,QAAQ,KAAK,OAAO;;AAQrD,kCAAyB,UAAU,cAAc,SAAU,UAAU;AACjE,cAAI,CAAC,CAAC,KAAK,WAAW,QAAQ,WAAW;AACrC,iBAAK,WAAW,KAAK;;AAGzB,cAAI,CAAC,KAAK,YAAY;AAClB,iBAAK;;;AASb,kCAAyB,UAAU,iBAAiB,SAAU,UAAU;AACpE,cAAI,aAAY,KAAK;AACrB,cAAI,SAAQ,WAAU,QAAQ;AAE9B,cAAI,CAAC,QAAO;AACR,uBAAU,OAAO,QAAO;;AAG5B,cAAI,CAAC,WAAU,UAAU,KAAK,YAAY;AACtC,iBAAK;;;AASb,kCAAyB,UAAU,UAAU,WAAY;AACrD,cAAI,kBAAkB,KAAK;AAG3B,cAAI,iBAAiB;AACjB,iBAAK;;;AAWb,kCAAyB,UAAU,mBAAmB,WAAY;AAE9D,cAAI,kBAAkB,KAAK,WAAW,OAAO,SAAU,UAAU;AAC7D,mBAAO,SAAS,gBAAgB,SAAS;;AAO7C,0BAAgB,QAAQ,SAAU,UAAU;AAAE,mBAAO,SAAS;;AAC9D,iBAAO,gBAAgB,SAAS;;AAQpC,kCAAyB,UAAU,WAAW,WAAY;AAGtD,cAAI,CAAC,aAAa,KAAK,YAAY;AAC/B;;AAEJ,cAAI,WAAW,KAAK;AACpB,cAAI,MAAM,SAAS,iBAAiB;AACpC,cAAI,MAAM,IAAI;AAId,mBAAS,iBAAiB,iBAAiB,KAAK,kBAAkB;AAClE,cAAI,KAAK;AACL,gBAAI,iBAAiB,UAAU,KAAK,SAAS;;AAEjD,cAAI,2BAA2B;AAC3B,iBAAK,qBAAqB,IAAI,iBAAiB,KAAK;AACpD,gBAAI;AACA,mBAAK,mBAAmB,QAAQ,UAAU;gBACtC,YAAY;gBACZ,WAAW;gBACX,eAAe;gBACf,SAAS;;qBAGV,GAAP;;AAKA,gBAAI,SAAS,MAAM;AACf,mBAAK,mBAAmB,QAAQ,SAAS,MAAM;gBAC3C,YAAY;gBACZ,WAAW;gBACX,eAAe;gBACf,SAAS;;;iBAIhB;AACD,qBAAS,iBAAiB,sBAAsB,KAAK,SAAS;AAC9D,iBAAK,uBAAuB;;AAGhC,cAAI,SAAS,MAAM;AACf,iBAAK,gBAAgB,IAAI,kBAAkB,KAAK,SAAS,KAAK,mBAAmB;AACjF,iBAAK,cAAc,QAAQ,SAAS;;AAExC,eAAK,aAAa;;AAQtB,kCAAyB,UAAU,cAAc,WAAY;AAGzD,cAAI,CAAC,aAAa,CAAC,KAAK,YAAY;AAChC;;AAEJ,cAAI,WAAW,KAAK;AACpB,cAAI,MAAM,SAAS,iBAAiB;AACpC,cAAI,MAAM,IAAI;AACd,mBAAS,oBAAoB,iBAAiB,KAAK,kBAAkB;AACrE,cAAI,KAAK;AACL,gBAAI,oBAAoB,UAAU,KAAK,SAAS;;AAEpD,cAAI,KAAK,oBAAoB;AACzB,iBAAK,mBAAmB;;AAE5B,cAAI,KAAK,sBAAsB;AAC3B,qBAAS,oBAAoB,sBAAsB,KAAK,SAAS;;AAErE,cAAI,KAAK,eAAe;AACpB,iBAAK,cAAc;;AAEvB,eAAK,gBAAgB;AACrB,eAAK,qBAAqB;AAC1B,eAAK,uBAAuB;AAC5B,eAAK,aAAa;;AAStB,kCAAyB,UAAU,mBAAmB,SAAU,IAAI;AAChE,cAAI,KAAK,GAAG,cAAc,eAAe,OAAO,SAAS,KAAK;AAE9D,cAAI,mBAAmB,eAAe,KAAK,SAAU,KAAK;AACtD,mBAAO,CAAC,CAAC,CAAC,aAAa,QAAQ;;AAEnC,cAAI,kBAAkB;AAClB,iBAAK;;;AAGb,eAAO;;AAMX,UAAI,iCAAgD,WAAY;AAC5D,mDAA0C;AAStC,eAAK,uBAAuB,OAAO,YAAY,cAAc,IAAI,YAAY,IAAI;;AASrF,wCAA+B,UAAU,cAAc,SAAU,UAAU,UAAU;AACjF,cAAI,qBAAqB,KAAK,qBAAqB,IAAI;AACvD,cAAI,CAAC,oBAAoB;AACrB,iCAAqB,IAAI,yBAAyB,UAAU;AAC5D,iBAAK,qBAAqB,IAAI,UAAU;;AAE5C,6BAAmB,YAAY;;AASnC,wCAA+B,UAAU,iBAAiB,SAAU,UAAU,UAAU;AACpF,cAAI,qBAAqB,KAAK,qBAAqB,IAAI;AACvD,cAAI,oBAAoB;AACpB,+BAAmB,eAAe;;;AAU1C,wCAA+B,UAAU,UAAU,SAAU,UAAU;AACnE,cAAI,qBAAqB,KAAK,qBAAqB,IAAI;AACvD,cAAI,oBAAoB;AACpB,+BAAmB;;;AAQ3B,wCAA+B,cAAc,WAAY;AACrD,cAAI,CAAC,KAAK,WAAW;AACjB,iBAAK,YAAY,IAAI;;AAEzB,iBAAO,KAAK;;AAOhB,wCAA+B,YAAY;AAC3C,eAAO;;AAMX,UAAI,YAAY,OAAO,YAAY,cAAc,IAAI,YAAY,IAAI;AAKrE,UAAI,iBAAgC,WAAY;AAO5C,iCAAwB,UAAU;AAC9B,cAAI,CAAE,iBAAgB,kBAAiB;AACnC,kBAAM,IAAI,UAAU;;AAExB,cAAI,CAAC,UAAU,QAAQ;AACnB,kBAAM,IAAI,UAAU;;AAExB,cAAI,aAAa,+BAA+B;AAChD,cAAI,WAAW,IAAI,kBAAkB,UAAU,YAAY;AAC3D,oBAAU,IAAI,MAAM;;AAExB,eAAO;;AAGX,OACI,WACA,aACA,cACF,QAAQ,SAAU,QAAQ;AACxB,uBAAe,UAAU,UAAU,WAAY;AAC3C,cAAI;AACJ,iBAAQ,MAAK,UAAU,IAAI,OAAO,QAAQ,MAAM,IAAI;;;AAI5D,UAAI,QAAS,WAAY;AAErB,YAAI,OAAO,SAAS,mBAAmB,aAAa;AAChD,iBAAO,SAAS;;AAEpB,eAAO;;AAGX,aAAO;;;;;ACtoCX,MAAI;AASG,6BAA2B;AAChC,QAAI,UAAU;AACZ,aAAO;;AAMT,eAAW,QAAQ,QAAQ;AAC3B,WAAO;;;;ACHF,MAAO,UAAW,MAAX;;;ACdd,MAAA,oBAAuD,OAAO;AAA9D,MAAuB,UAAvB,kBAAO;AAAP,MAA0C,YAA1C,kBAAgC;AAmBzB,eAAa,aAAa;AAC/B,QAAM,MAAM,OAAO,OAAO;AAC1B,QAAI,aAAa;AACf,aAAO,OAAO,KAAK;;AAErB,WAAO;;;;AChBF,oCAAkC;AACvC,WAAO;;;;ACRT,MAAM,qBAAqB;AAUpB,iCAA+B,WAAW,UAAe;AAAA,QAAf,aAAe,QAAA;AAAf,iBAAW;;AAC1D,QAAI;AACF,aAAO,mBAAmB;aACnB,GAAP;AACA,aAAO;;;AAWJ,4BAA0B,aAAa;AAC5C,QAAM,SAAS;AACf,QAAI,CAAC,aAAa;AAChB,aAAO;;AAGT,QAAI;AACJ,WAAQ,QAAQ,mBAAmB,KAAK,cAAe;AACrD,UAAM,OAAO,sBAAsB,MAAM,IAAI,MAAM;AACnD,UAAM,QAAQ,MAAM,KAChB,sBAAsB,MAAM,GAAG,QAAQ,OAAO,MAAM,MAAM,MAC1D;AACJ,aAAO,QAAQ;;AAEjB,WAAO;;;;AChBT,MAAI,aAAa;AAOV,mBAAiB,SAAS;AAC/B,QAAM,MAAM,WAAW;AACvB,QAAI,IAAI,YAAY;AAClB,aAAO,IAAI;;AAEb,WAAQ,IAAI,aAAa,SAAS;;AAQpC,oBAAkB,KAAK;AAErB,QAAM,aAAa,KAAK,cAAc;AAMtC,QAAM,gBAAgB;AACtB,QAAM,cAAc;AAEpB,QAAM,eACJ,iBAAiB,CAAC,CAAE,YAAW,QAAQ,IAAI,cAAc,IAAI;AAC/D,QAAM,aAAa,iBAAkB,EAAC,CAAC,WAAW,YAAY;AAC9D,QAAM,YAAY,iBAGhB,IAAI,SAAS,mBAAmB,IAAI,SAAS;AAG/C,QAAI,CAAC,YAAY;AACf,mBAAa,cAAc;;AAO7B,WAAO;MACL,UAAU;MACV,aAAa,kBAAkB;MAC/B,UAAU,UAAU,kBAAkB;MACtC,KAAG;MAEH,aAAa,UAAU;MACvB,UAAU;MACV,MAAM;MACN,KAAK,UAAU;MACf,SAAS;MACT;;;AAWJ,yBAAuB,KAAK;AAC1B,QAAI,IAAI,cAAc,IAAI,WAAW,GAAG;AACtC,aAAO,IAAI,WAAW;;AAQxB,WAAA,OAAY;;AAUP,6BAA2B,KAAK;AACrC,QAAM,YAAY,iBAChB,IAAI,SAAS,mBAAmB,IAAI,SAAS;AAE/C,WAAO,CAAC,CACN,EAAC,KAAK,WAAW,OAAO,WAAW,aAAa,SAC9C,UAAU,mBACP,IAAI;;;;ACnHb,MAAM,MAAM,KAAK,cAAc;AAE/B,MAAM,uBACH,QAAO,IAAI,2BAA2B,WACnC,IAAI,OAAO,IAAI,2BACf,IAAI,4BAA4B;AAEtC,MAAM,gBACH,QAAO,IAAI,oBAAoB,WAC5B,IAAI,OAAO,IAAI,oBACf,IAAI,qBACR;AAYF,sBAAoB,MAAM;AAExB,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,SAAS,MAAM;AACzC,aAAO;;AAIT,QAAI,KAAK,YAAY,cAAc,KAAK,KAAK,SAAS,SAAS;AAC7D,aAAO;;AAGT,QAAM,SAAS,KAAK,SAAS,KAAY,cAA1B,gBACC,OADD;AAGf,WAAQ,UAAU,OAAO,aAAa,cAAe;;AAkBhD,MAAM,OAAO;IAClB,YAAY,IAAI,oBAAoB;IACpC,qBAAqB,IAAI,0BAA0B;IACnD;IACA,KACE,IAAI,aAAa,WAAW,mBAAmB;IAIjD;IACA,gBAAgB;IAChB,gBACE,IAAI,wBACJ;IACF,oBACE,IAAI,4BACJ;IACF,UAAU,IAAI,eAAe;IAU7B,oBAAoB,CAClB,qDACA;IAGF,QAAQ,IAAI,gBAAgB,WAAW;;;;ACxDlC,MAAM,WAAW;IACtB,KAAK;IACL,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;;AA8eR,OAAK,YAAY,KAAK,aAAa;IACjC,MAAM;IACN,KAAK;IACL,cAAc;;AAGhB,MAAM,OAAO,KAAK;AAQlB,MAAI,iBAAiB;AAqFd,iBAAe;AACpB,QAAI,KAAK,KAAK;AACZ,aAAO,KAAK;;AAEd,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI,MAAM;;AAElB,WAAQ,KAAK,MAAM,IAAI,eAAe,MAAM,SAAC,QAAW;AACtD,UAAI,UAAU,GAAG;AACf,eAAO,SAAS;;AAElB,UAAI,UAAU,GAAG;AACf,eAAO,SAAS;;AAElB,aAAO,SAAS;;;AA6Cb,qBACL,iBACA,aACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA;AACA,QAAI,UAAU,UAAU;AACtB,aAAO;;AAET,QAAI,KAAK,uBAAuB;AAK9B,cACG,IAAI;;AAGT,WAAO,MAAoB,OACzB,iBACA,aACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA;;;;ACxoBG,kCAAgC,KAAK,IAAI,aAAa,iBAAiB;AAC5E,UAAM,aAAa;AACnB,4BAAwB,KAAK,KAAK,IAAI;AACtC,QAAI,iBAAiB;AACnB,yBAAmB,KAAK;;;AA0LrB,wBAAsB,KAAK;AAChC,WAAO,IAAI,aAAc,KAAI,YAAY;;AAiE3C,8BAA4B,QAAQ,IAAI;AACtC,cACE,oBAAoB,QAAQ,KADrB,sBAEa,KAFb;AAIT,QAAM,WAAW,YAAY;AAC7B,QAAM,IAAI,SAAS;AACnB,QAAI,CAAC,EAAE,KAAK;AACV,gBAAU,EAAE,MAAH,aAAoB,KAApB;AACT,gBAAU,EAAE,SAAH,aAAuB,KAAvB;AACT,QAAE,MAAM,IAAI,EAAE,KAAK,EAAE;AACrB,gBAAU,EAAE,KAAH,aAAmB,KAAnB;AACT,QAAE,UAAU;AAGZ,UAAI,EAAE,SAAS;AACb,UAAE,QAAQ,EAAE;;;AAGhB,WAAO,EAAE;;AAWX,mCACE,QACA,SACA,IACA,MACA,cACA,oBACA;AACA,QAAM,WAAW,YAAY;AAC7B,QAAI,IAAI,SAAS;AAEjB,QAAI,CAAC,GAAG;AACN,UAAI,SAAS,MAAM;QACjB,KAAK;QACL,SAAS;QACT,SAAS;QACT,QAAQ;QACR,SAAS;QACT,MAAM;QACN,gBAAgB,sBAAsB;;;AAI1C,QAAI,CAAC,gBAAgB,EAAE,MAAM;AAE3B;;AAGF,MAAE,OAAO;AACT,MAAE,UAAU;AACZ,MAAE,iBAAiB,sBAAsB;AAIzC,QAAI,EAAE,SAAS;AAEb,yBAAmB,QAAQ;;;AAqE/B,uBAAqB,QAAQ;AAC3B,QAAI,WAAW,OAAO;AACtB,QAAI,CAAC,UAAU;AACb,iBAAW,OAAO,iBAAiB;;AAErC,WAAO;;AAqJT,+BAA6B,QAAQ,IAAI;AACvC,QAAM,UAAU,OAAO,kBAAkB,OAAO,eAAe;AAE/D,WAAO,CAAC,CAAE,YAAW,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3mB/B,MAAM,YAAY;AAClB,MAAM,OAAO;AA6BN,2BAAyB,KAAK,WAAW;AAG9C,QAAM,OAAO,IAAI,eAAe;AAChC,QAAI,MAAM;AACR,aAAO,IAAI;AACX,aAAO,IAAI;AACX;AAEA,UAAM,WAAW,IAAI;AAErB,UAAM,YAAY,KAAK,WAAW,MAAM;AACxC,UAAM,YAAY;AAClB,UAAM,WAAU,kBAAC,WAAa;AAC5B,kBAAU,KAAK,WAAA;AAAA,iBAAM,UAAS;;;AAEhC,eAAA,YAAA,gCAAuB,YAAvB,OAAA,CAAA,SAAA,aAAA,QAAkC;AAAA,YAAvB,WAAuB,MAAA;AAChC,iBAAQ;;AAEV,WAAK,aAAa;QAAC,QAAQ;;WACtB;AAGL;;;AAYJ,MAAa,qBAAb,2BAAA;AAEE,iCAAY,UAAU;AAAA,sBAAA,MAAA;AAEpB,WAAK,YAAY;AAGjB,WAAK,YAAY;AAGjB,WAAK,QAAQ;AAGb,0BAAmB,WAAW,KAAK,KAAK,SAAS,KAAK;;AAb1D,iBAAA,qBAAA,CAAA;MAAA,KAAA;MAAA,OAiBE,sBAAa;AACX,YAAI,KAAK,OAAO;AACd,eAAK,MAAM;eACN;AACL,eAAK,UAAU,SAAS;;;OArB9B;MAAA,KAAA;MAAA,OA0BE,iBAAQ,QAAQ;AACd,YAAI,KAAK,OAAO;AACd,eAAK,MAAM,QAAQ;eACd;AACL,cAAI,KAAK,UAAU,QAAQ,WAAW,IAAI;AACxC,iBAAK,UAAU,KAAK;;;;OA/B5B;MAAA,KAAA;MAAA,OAqCE,mBAAU,QAAQ;AAChB,YAAI,KAAK,OAAO;AACd,eAAK,MAAM,UAAU;eAChB;AACL,cAAM,QAAQ,KAAK,UAAU,QAAQ;AACrC,cAAI,SAAS,IAAI;AACf,iBAAK,UAAU,OAAO,OAAO;;;;OA3CrC;MAAA,KAAA;MAAA,OAoDE,kBAAS,MAAM;AACb,YAAM,OAAO,IAAI,KAAK,KAAK;AAC3B,aAAK,QAAQ;AACb,iBAAA,aAAA,gCAAgB,KAAK,YAArB,QAAA,CAAA,UAAA,cAAA,QAAgC;AAAA,cAArB,IAAqB,OAAA;AAC9B,eAAK,QAAQ;;AAEf,aAAK,UAAU,SAAS;;;AA1D5B,WAAA;;AA+DA,qBAAmB,aAAa;;;ACxIhC,MAAM,MAAM;AAMZ,mBAAiB,KAAK;AACpB,oBAAgB,KAAK,WAAM;AACzB,4BAAsB;;AAExB,WAAO;;AAOF,yCAAuC,KAAK;AACjD,2BAAuB,KAAK,KAAK,SAA2B;;AAI9D,MAAI,UAAU,KAAK,OAAO,SAAU,MAAK;AACvC,kCAA8B;;",
  "names": []
}
