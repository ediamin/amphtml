{
  "version": 3,
  "sources": ["../../../extensions/amp-viewer-integration/0.1/messaging/messaging.js", "../../../extensions/amp-viewer-integration/0.1/examples/amp-viewer-host.js"],
  "sourcesContent": ["/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst TAG = 'amp-viewer-messaging';\nconst CHANNEL_OPEN_MSG = 'channelOpen';\nconst HANDSHAKE_POLL_MSG = 'handshake-poll';\nconst APP = '__AMPHTML__';\n\n/**\n * @enum {string}\n */\nconst MessageType = {\n  REQUEST: 'q',\n  RESPONSE: 's',\n};\n\n/**\n * @typedef {function(string, *, boolean):(!Promise<*>|undefined)}\n */\nlet RequestHandler; // eslint-disable-line no-unused-vars\n\n/**\n * @param {*} message\n * @return {?AmpViewerMessage}\n */\nexport function parseMessage(message) {\n  if (typeof message != 'string') {\n    return /** @type {AmpViewerMessage} */ (message);\n  }\n  if (message.charAt(0) != '{') {\n    return null;\n  }\n\n  try {\n    return /** @type {?AmpViewerMessage} */ (\n      JSON.parse(/** @type {string} */ (message))\n    );\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * @fileoverview This class is a de-facto implementation of MessagePort\n * from Channel Messaging API:\n * https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API\n */\nexport class WindowPortEmulator {\n  /**\n   * @param {!Window} win\n   * @param {string} origin\n   * @param {!Window} target\n   */\n  constructor(win, origin, target) {\n    /** @const @private {!Window} */\n    this.win_ = win;\n    /** @const @private {string} */\n    this.origin_ = origin;\n    /** @const @private {!Window} */\n    this.target_ = target;\n  }\n\n  /**\n   * @param {string} eventType\n   * @param {function(!Event):*} handler\n   */\n  addEventListener(eventType, handler) {\n    this.win_.addEventListener('message', (event) => {\n      if (event.origin == this.origin_ && event.source == this.target_) {\n        handler(event);\n      }\n    });\n  }\n\n  /**\n   * @param {JsonObject} data\n   */\n  postMessage(data) {\n    // Opaque (null) origin can only receive messages sent to \"*\"\n    const targetOrigin = this.origin_ === 'null' ? '*' : this.origin_;\n\n    this.target_./*OK*/ postMessage(data, targetOrigin);\n  }\n\n  /**\n   * Starts the sending of messages queued on the port.\n   */\n  start() {}\n}\n\n/**\n * @fileoverview This is used in amp-viewer-integration.js for the\n * communication protocol between AMP and the viewer. In the comments, I will\n * refer to the communication as a conversation between me and Bob. The\n * messaging protocol should support both sides, but at this point I'm the\n * ampdoc and Bob is the viewer.\n */\nexport class Messaging {\n  /**\n   * Performs a handshake and initializes messaging.\n   *\n   * Requires the `handshakepoll` viewer capability and the `origin` viewer parameter to be specified.\n   * @param {!Window} target - window containing AMP document to perform handshake with\n   * @param {?string=} opt_token - message token to verify on incoming messages (must be provided as viewer parameter)\n   * @return {!Promise<!Messaging>}\n   */\n  static initiateHandshakeWithDocument(target, opt_token) {\n    return new Promise((resolve) => {\n      const intervalRef = setInterval(() => {\n        const channel = new MessageChannel();\n        const pollMessage = /** @type {JsonObject} */ ({\n          app: APP,\n          name: HANDSHAKE_POLL_MSG,\n        });\n        target./*OK*/ postMessage(pollMessage, '*', [channel.port2]);\n\n        const port = channel.port1;\n        const listener = (event) => {\n          const message = parseMessage(event.data);\n          if (!message) {\n            return;\n          }\n          if (message.app === APP && message.name === CHANNEL_OPEN_MSG) {\n            clearInterval(intervalRef);\n            port.removeEventListener('message', listener);\n            const messaging = new Messaging(\n              null,\n              port,\n              /* opt_isWebview */ false,\n              opt_token,\n              /* opt_verifyToken */ true\n            );\n            messaging.sendResponse_(message.requestid, CHANNEL_OPEN_MSG, null);\n            resolve(messaging);\n          }\n        };\n        port.addEventListener('message', listener);\n        port.start();\n      }, 1000);\n    });\n  }\n\n  /**\n   * Waits for handshake from iframe and initializes messaging.\n   *\n   * Requires the `origin` viewer parameter to be specified.\n   * @param {!Window} source - the source window containing the viewer\n   * @param {!Window} target - window containing AMP document to perform handshake with (usually contentWindow of iframe)\n   * @param {string} origin - origin of target window (use \"null\" if opaque)\n   * @param {?string=} opt_token - message token to verify on incoming messages (must be provided as viewer parameter)\n   * @param {?RegExp=} opt_cdnProxyRegex\n   * @return {!Promise<!Messaging>}\n   */\n  static waitForHandshakeFromDocument(\n    source,\n    target,\n    origin,\n    opt_token,\n    opt_cdnProxyRegex\n  ) {\n    return new Promise((resolve) => {\n      const listener = (event) => {\n        const message = parseMessage(event.data);\n        if (!message) {\n          return;\n        }\n        if (\n          (event.origin == origin ||\n            (opt_cdnProxyRegex && opt_cdnProxyRegex.test(event.origin))) &&\n          (!event.source || event.source == target) &&\n          message.app === APP &&\n          message.name === CHANNEL_OPEN_MSG\n        ) {\n          source.removeEventListener('message', listener);\n          const port = new WindowPortEmulator(source, event.origin, target);\n          const messaging = new Messaging(\n            null,\n            port,\n            /* opt_isWebview */ false,\n            opt_token,\n            /* opt_verifyToken */ true\n          );\n          messaging.sendResponse_(message.requestid, CHANNEL_OPEN_MSG, null);\n          resolve(messaging);\n        }\n      };\n      source.addEventListener('message', listener);\n    });\n  }\n\n  /**\n   * Conversation (messaging protocol) between me and Bob.\n   * @param {?Window} win\n   * @param {!MessagePort|!WindowPortEmulator} port\n   * @param {boolean=} opt_isWebview\n   * @param {?string=} opt_token\n   * @param {boolean=} opt_verifyToken\n   */\n  constructor(win, port, opt_isWebview, opt_token, opt_verifyToken) {\n    /** @const @private {?Window} */\n    this.win_ = win;\n    /** @const @private {!MessagePort|!WindowPortEmulator} */\n    this.port_ = port;\n    /** @const @private {boolean} */\n    this.isWebview_ = !!opt_isWebview;\n\n    /**\n     * A token that the viewer may include as an init parameter to enhance\n     * security for communication to opaque origin (a.k.a. null origin) AMP\n     * documents.\n     *\n     * For an AMP document embedded inside a sandbox iframe, the origin of the\n     * document would be \"null\", which defeats the purpose of an origin check.\n     * An attacker could simply create a sandboxed, malicious iframe (therefore\n     * having null origin), walk on the DOM frame tree to find a reference to\n     * the viewer iframe (this is not constrained by the same origin policy),\n     * and then send postMessage() calls to the viewer frame and pass the\n     * viewer's origin checks, if any.\n     *\n     * The viewer could also check the source of the message to be a legitimate\n     * AMP iframe window, but the attacker could bypass that by navigating the\n     * legitimate AMP iframe window away to a malicious document. Recent\n     * browsers have banned this kind of attack, but it's tricky to rely on it.\n     *\n     * To prevent the above attack in a null origin AMP document, the viewer\n     * should include this token in an init parameter, either in the `src` or\n     * `name` attribute of the iframe, and then verify that this token is\n     * included in all the messages sent from AMP to the viewer. The attacker\n     * would not be able to steal this token under the same origin policy,\n     * because the token is inside the viewer document at a different origin\n     * and the attacker can't access it.\n     * @const @private {?string}\n     */\n    this.token_ = opt_token || null;\n\n    /**\n     * If true, the token above is verified on incoming messages instead of\n     * being attached to outgoing messages.\n     * @const @private {boolean}\n     */\n    this.verifyToken_ = !!opt_verifyToken;\n\n    /** @private {number} */\n    this.requestIdCounter_ = 0;\n    /** @private {!Object<number, {resolve: function(*), reject: function(!Error)}>} */\n    this.waitingForResponse_ = {};\n    /**\n     * A map from message names to request handlers.\n     * @private {!Object<string, !RequestHandler>}\n     */\n    this.messageHandlers_ = {};\n\n    /** @private {?RequestHandler} */\n    this.defaultHandler_ = null;\n\n    this.port_.addEventListener('message', this.handleMessage_.bind(this));\n    this.port_.start();\n  }\n\n  /**\n   * Registers a method that will handle requests sent to the specified\n   * message name.\n   * @param {string} messageName The name of the message to handle.\n   * @param {!RequestHandler} requestHandler\n   */\n  registerHandler(messageName, requestHandler) {\n    this.messageHandlers_[messageName] = requestHandler;\n  }\n\n  /**\n   * Unregisters the handler for the specified message name.\n   * @param {string} messageName The name of the message to unregister.\n   */\n  unregisterHandler(messageName) {\n    delete this.messageHandlers_[messageName];\n  }\n\n  /**\n   * @param {?RequestHandler} requestHandler\n   */\n  setDefaultHandler(requestHandler) {\n    this.defaultHandler_ = requestHandler;\n  }\n\n  /**\n   * Bob sent me a message. I need to decide if it's a new request or\n   * a response to a previous 'conversation' we were having.\n   * @param {!Event} event\n   * @private\n   */\n  handleMessage_(event) {\n    const message = parseMessage(event.data);\n    if (!message || message.app !== APP) {\n      return;\n    }\n    if (\n      this.token_ &&\n      this.verifyToken_ &&\n      message.messagingToken !== this.token_\n    ) {\n      // We received a message with an invalid token - dismiss it.\n      this.logError_(TAG + ': handleMessage_ error: ', 'invalid token');\n      return;\n    }\n    if (message.type === MessageType.REQUEST) {\n      this.handleRequest_(message);\n    } else if (message.type === MessageType.RESPONSE) {\n      this.handleResponse_(message);\n    }\n  }\n\n  /**\n   * I'm sending Bob a new outgoing request.\n   * @param {string} messageName\n   * @param {?JsonObject|string|undefined} messageData\n   * @param {boolean} awaitResponse\n   * @return {!Promise<*>|undefined}\n   */\n  sendRequest(messageName, messageData, awaitResponse) {\n    const requestId = ++this.requestIdCounter_;\n    let promise = undefined;\n    if (awaitResponse) {\n      promise = new Promise((resolve, reject) => {\n        this.waitingForResponse_[requestId] = {resolve, reject};\n      });\n    }\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.REQUEST,\n        name: messageName,\n        data: messageData,\n        rsvp: awaitResponse,\n      })\n    );\n    return promise;\n  }\n\n  /**\n   * I'm responding to a request that Bob made earlier.\n   * @param {number} requestId\n   * @param {string} messageName\n   * @param {*} messageData\n   * @private\n   */\n  sendResponse_(requestId, messageName, messageData) {\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.RESPONSE,\n        name: messageName,\n        data: messageData,\n      })\n    );\n  }\n\n  /**\n   * @param {number} requestId\n   * @param {string} messageName\n   * @param {*} reason !Error most of time, string sometimes, * rarely.\n   * @private\n   */\n  sendResponseError_(requestId, messageName, reason) {\n    const errString = this.errorToString_(reason);\n    this.logError_(\n      TAG + ': sendResponseError_, message name: ' + messageName,\n      errString\n    );\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.RESPONSE,\n        name: messageName,\n        data: null,\n        error: errString,\n      })\n    );\n  }\n\n  /**\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  sendMessage_(message) {\n    const /** Object<string, *> */ finalMessage = Object.assign(message, {});\n    if (this.token_ && !this.verifyToken_) {\n      finalMessage.messagingToken = this.token_;\n    }\n    this.port_./*OK*/ postMessage(\n      this.isWebview_\n        ? JSON.stringify(/** @type {!JsonObject} */ (finalMessage))\n        : finalMessage\n    );\n  }\n\n  /**\n   * I'm handling an incoming request from Bob. I'll either respond normally\n   * (ex: \"got it Bob!\") or with an error (ex: \"I didn't get a word of what\n   * you said!\").\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  handleRequest_(message) {\n    let handler = this.messageHandlers_[message.name];\n    if (!handler) {\n      handler = this.defaultHandler_;\n    }\n    if (!handler) {\n      const error = new Error(\n        'Cannot handle request because no default handler is set!'\n      );\n      error.args = message.name;\n      throw error;\n    }\n\n    const promise = handler(message.name, message.data, !!message.rsvp);\n    if (message.rsvp) {\n      const requestId = message.requestid;\n      if (!promise) {\n        this.sendResponseError_(\n          requestId,\n          message.name,\n          new Error('no response')\n        );\n        throw new Error('expected response but none given: ' + message.name);\n      }\n      promise.then(\n        (data) => {\n          this.sendResponse_(requestId, message.name, data);\n        },\n        (reason) => {\n          this.sendResponseError_(requestId, message.name, reason);\n        }\n      );\n    }\n  }\n\n  /**\n   * I sent out a request to Bob. He responded. And now I'm handling that\n   * response.\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  handleResponse_(message) {\n    const requestId = message.requestid;\n    const pending = this.waitingForResponse_[requestId];\n    if (pending) {\n      delete this.waitingForResponse_[requestId];\n      if (message.error) {\n        this.logError_(TAG + ': handleResponse_ error: ', message.error);\n        pending.reject(\n          new Error(`Request ${message.name} failed: ${message.error}`)\n        );\n      } else {\n        pending.resolve(message.data);\n      }\n    }\n  }\n\n  /**\n   * @param {string} state\n   * @param {!Error|string=} opt_data\n   * @private\n   */\n  logError_(state, opt_data) {\n    if (!this.win_) {\n      return;\n    }\n    let stateStr = 'amp-messaging-error-logger: ' + state;\n    const dataStr = ' data: ' + this.errorToString_(opt_data);\n    stateStr += dataStr;\n    this.win_['viewerState'] = stateStr;\n  }\n\n  /**\n   * @param {*} err !Error most of time, string sometimes, * rarely.\n   * @return {string}\n   * @private\n   */\n  errorToString_(err) {\n    return err ? (err.message ? err.message : String(err)) : 'unknown error';\n  }\n}\n", "/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Messaging} from '../messaging/messaging';\n\n/**\n * @fileoverview This is an example of how the viewer host can be implemented\n * for communication with the AMP docs.\n */\nexport class AmpViewerHost {\n  /**\n   * @param {!Window} win\n   * @param {!HTMLIFrameElement} ampIframe\n   * @param {string} frameOrigin\n   * @param {function(string, *, boolean):(!Promise<*>|undefined)} messageHandler\n   * @param {string=} opt_logsId For dev logs so you know what ampdoc you're\n   * @param {boolean=} opt_isWebview Should viewer initiate handshake w/ polling\n   * @param {boolean=} opt_isHandshakePoll\n   * looking at.\n   */\n  constructor(\n    win,\n    ampIframe,\n    frameOrigin,\n    messageHandler,\n    opt_logsId,\n    opt_isWebview,\n    opt_isHandshakePoll\n  ) {\n    /** @const {!Window} */\n    this.win = win;\n    /** @private {!HTMLIFrameElement} */\n    this.ampIframe_ = ampIframe;\n    /** @private {function(string, *, boolean):(!Promise<*>|undefined)} */\n    this.messageHandler_ = messageHandler;\n    /** @const {boolean} */\n    this.isWebview_ = !!opt_isWebview;\n    /** @const {string} */\n    this.logsId = opt_logsId;\n\n    const target = this.ampIframe_.contentWindow;\n    if (this.isWebview_ || opt_isHandshakePoll) {\n      Messaging.initiateHandshakeWithDocument(target).then((messaging) => {\n        this.messaging_ = messaging;\n        this.completeHandshake_();\n      });\n    } else {\n      Messaging.waitForHandshakeFromDocument(\n        this.win,\n        target,\n        frameOrigin\n      ).then((messaging) => {\n        this.messaging_ = messaging;\n        this.completeHandshake_();\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  completeHandshake_() {\n    this.messaging_.setDefaultHandler(this.messageHandler_);\n\n    this.sendRequest(\n      'visibilitychange',\n      {\n        state: this.visibilityState_,\n        prerenderSize: this.prerenderSize,\n      },\n      true\n    );\n  }\n\n  /**\n   * @param {string} type\n   * @param {*} data\n   * @param {boolean} awaitResponse\n   * @return {!Promise<*>|undefined}\n   */\n  sendRequest(type, data, awaitResponse) {\n    this.log('sendRequest');\n    if (!this.messaging_) {\n      return;\n    }\n    return this.messaging_.sendRequest(type, data, awaitResponse);\n  }\n\n  /**\n   * Logs viewer arguments.\n   *\n   */\n  log() {\n    const var_args = Array.prototype.slice.call(arguments, 0);\n    var_args.unshift('[ViewerHost ' + this.logsId + ']');\n    console /*OK*/.log\n      .apply(console, var_args);\n  }\n}\n\nself.AmpViewerHost = AmpViewerHost;\n"],
  "mappings": "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",
  "names": []
}
